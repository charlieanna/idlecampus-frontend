[
  {
    "id": "q_206",
    "title": "Reverse Linked List",
    "prompt": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "concept_taught": "Iterative Pointer Reversal",
    "starterCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseList(head: ListNode) -> ListNode:\n    \"\"\"Reverse the linked list and return new head.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 2, 3, 4, 5]", "expectedOutput": "[5, 4, 3, 2, 1]"},
      {"id": "test-2", "input": "[1, 2]", "expectedOutput": "[2, 1]"},
      {"id": "test-3", "input": "[]", "expectedOutput": "[]"}
    ],
    "hints": [
      "Use three pointers: prev, curr, next.",
      "Reverse the direction of each link.",
      "Move all pointers forward after each reversal."
    ],
    "solution": "def reverseList(head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n    \n    return prev"
  },
  {
    "id": "q_21",
    "title": "Merge Two Sorted Lists",
    "prompt": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.",
    "concept_taught": "Pointer Merging",
    "starterCode": "def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode:\n    \"\"\"Merge two sorted lists into one sorted list.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 2, 4], [1, 3, 4]", "expectedOutput": "[1, 1, 2, 3, 4, 4]"},
      {"id": "test-2", "input": "[], []", "expectedOutput": "[]"},
      {"id": "test-3", "input": "[], [0]", "expectedOutput": "[0]"}
    ],
    "hints": [
      "Use a dummy head node to simplify logic.",
      "Compare current nodes, attach smaller one.",
      "Handle remaining nodes when one list exhausted."
    ],
    "solution": "def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode:\n    dummy = ListNode()\n    curr = dummy\n    \n    while list1 and list2:\n        if list1.val <= list2.val:\n            curr.next = list1\n            list1 = list1.next\n        else:\n            curr.next = list2\n            list2 = list2.next\n        curr = curr.next\n    \n    curr.next = list1 or list2\n    return dummy.next"
  },
  {
    "id": "q_141",
    "title": "Linked List Cycle",
    "prompt": "Given head, the head of a linked list, determine if the linked list has a cycle in it. A cycle exists if some node can be reached again by continuously following the next pointer.",
    "concept_taught": "Floyd's Cycle Detection",
    "starterCode": "def hasCycle(head: ListNode) -> bool:\n    \"\"\"Return True if linked list has a cycle.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[3, 2, 0, -4], pos=1", "expectedOutput": "true"},
      {"id": "test-2", "input": "[1, 2], pos=0", "expectedOutput": "true"},
      {"id": "test-3", "input": "[1], pos=-1", "expectedOutput": "false"}
    ],
    "hints": [
      "Use fast and slow pointers (tortoise and hare).",
      "Fast moves 2 steps, slow moves 1 step.",
      "If they meet, there's a cycle."
    ],
    "solution": "def hasCycle(head: ListNode) -> bool:\n    if not head or not head.next:\n        return False\n    \n    slow = head\n    fast = head.next\n    \n    while slow != fast:\n        if not fast or not fast.next:\n            return False\n        slow = slow.next\n        fast = fast.next.next\n    \n    return True"
  },
  {
    "id": "q_20",
    "title": "Valid Parentheses",
    "prompt": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets and in the correct order.",
    "concept_taught": "Basic Stack",
    "starterCode": "def isValid(s: str) -> bool:\n    \"\"\"Return True if parentheses are valid.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "\"()\"", "expectedOutput": "true"},
      {"id": "test-2", "input": "\"()[]{}\"", "expectedOutput": "true"},
      {"id": "test-3", "input": "\"(]\"", "expectedOutput": "false"}
    ],
    "hints": [
      "Use a stack to track opening brackets.",
      "For closing bracket, check if it matches top of stack.",
      "Stack should be empty at end for valid string."
    ],
    "solution": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    \n    return len(stack) == 0"
  },
  {
    "id": "q_155",
    "title": "Min Stack",
    "prompt": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    "concept_taught": "Auxiliary Stack",
    "starterCode": "class MinStack:\n    def __init__(self):\n        pass\n    \n    def push(self, val: int) -> None:\n        pass\n    \n    def pop(self) -> None:\n        pass\n    \n    def top(self) -> int:\n        pass\n    \n    def getMin(self) -> int:\n        pass",
    "testCases": [
      {"id": "test-1", "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"], [[],[-2],[0],[-3],[],[],[],[]]", "expectedOutput": "[null,null,null,null,-3,null,0,-2]"}
    ],
    "hints": [
      "Keep a second stack to track minimums.",
      "Push to min stack when value <= current min.",
      "Pop from min stack when popping the minimum."
    ],
    "solution": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self) -> None:\n        if self.stack.pop() == self.min_stack[-1]:\n            self.min_stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1]\n    \n    def getMin(self) -> int:\n        return self.min_stack[-1]"
  },
  {
    "id": "q_739",
    "title": "Daily Temperatures",
    "prompt": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "concept_taught": "Intro to Monotonic Stack",
    "starterCode": "def dailyTemperatures(temperatures: list[int]) -> list[int]:\n    \"\"\"Return days to wait for warmer temperature.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[73, 74, 75, 71, 69, 72, 76, 73]", "expectedOutput": "[1, 1, 4, 2, 1, 1, 0, 0]"},
      {"id": "test-2", "input": "[30, 40, 50, 60]", "expectedOutput": "[1, 1, 1, 0]"},
      {"id": "test-3", "input": "[30, 60, 90]", "expectedOutput": "[1, 1, 0]"}
    ],
    "hints": [
      "Use a stack to store indices of decreasing temperatures.",
      "When warmer temp found, pop and calculate days.",
      "Process from left to right."
    ],
    "solution": "def dailyTemperatures(temperatures: list[int]) -> list[int]:\n    n = len(temperatures)\n    answer = [0] * n\n    stack = []  # stores indices\n    \n    for i, temp in enumerate(temperatures):\n        while stack and temperatures[stack[-1]] < temp:\n            prev_idx = stack.pop()\n            answer[prev_idx] = i - prev_idx\n        stack.append(i)\n    \n    return answer"
  },
  {
    "id": "q_150",
    "title": "Evaluate Reverse Polish Notation",
    "prompt": "Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression.",
    "concept_taught": "Post-fix Evaluation",
    "starterCode": "def evalRPN(tokens: list[str]) -> int:\n    \"\"\"Evaluate the RPN expression and return result.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[\"2\",\"1\",\"+\",\"3\",\"*\"]", "expectedOutput": "9"},
      {"id": "test-2", "input": "[\"4\",\"13\",\"5\",\"/\",\"+\"]", "expectedOutput": "6"},
      {"id": "test-3", "input": "[\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]", "expectedOutput": "22"}
    ],
    "hints": [
      "Use a stack to store operands.",
      "When operator found, pop two operands and compute.",
      "Push result back onto stack."
    ],
    "solution": "def evalRPN(tokens: list[str]) -> int:\n    stack = []\n    ops = {'+', '-', '*', '/'}\n    \n    for token in tokens:\n        if token in ops:\n            b, a = stack.pop(), stack.pop()\n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]"
  },
  {
    "id": "q_876",
    "title": "Middle of the Linked List",
    "prompt": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",
    "concept_taught": "Fast and Slow Pointers",
    "starterCode": "def middleNode(head: ListNode) -> ListNode:\n    \"\"\"Return the middle node of the linked list.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 2, 3, 4, 5]", "expectedOutput": "[3, 4, 5]"},
      {"id": "test-2", "input": "[1, 2, 3, 4, 5, 6]", "expectedOutput": "[4, 5, 6]"},
      {"id": "test-3", "input": "[1]", "expectedOutput": "[1]"}
    ],
    "hints": [
      "Use fast and slow pointers.",
      "Fast moves 2 steps, slow moves 1 step.",
      "When fast reaches end, slow is at middle."
    ],
    "solution": "def middleNode(head: ListNode) -> ListNode:\n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    return slow"
  },
  {
    "id": "q_237",
    "title": "Delete Node in a Linked List",
    "prompt": "Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. It is guaranteed that the node to be deleted is not a tail node.",
    "concept_taught": "Node Value Copying",
    "starterCode": "def deleteNode(node: ListNode) -> None:\n    \"\"\"Delete the given node from the list.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "head = [4,5,1,9], node = 5", "expectedOutput": "[4, 1, 9]"},
      {"id": "test-2", "input": "head = [4,5,1,9], node = 1", "expectedOutput": "[4, 5, 9]"},
      {"id": "test-3", "input": "head = [1,2,3,4], node = 3", "expectedOutput": "[1, 2, 4]"}
    ],
    "hints": [
      "You can't access the previous node.",
      "Copy the next node's value to current node.",
      "Delete the next node instead."
    ],
    "solution": "def deleteNode(node: ListNode) -> None:\n    node.val = node.next.val\n    node.next = node.next.next"
  },
  {
    "id": "q_496",
    "title": "Next Greater Element I",
    "prompt": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. Given two arrays nums1 and nums2 where nums1 is a subset of nums2, find the next greater element for each element of nums1 in nums2.",
    "concept_taught": "Simple Monotonic Stack",
    "starterCode": "def nextGreaterElement(nums1: list[int], nums2: list[int]) -> list[int]:\n    \"\"\"Return next greater element for each element in nums1.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[4, 1, 2], [1, 3, 4, 2]", "expectedOutput": "[-1, 3, -1]"},
      {"id": "test-2", "input": "[2, 4], [1, 2, 3, 4]", "expectedOutput": "[3, -1]"},
      {"id": "test-3", "input": "[1, 3, 5, 2, 4], [6, 5, 4, 3, 2, 1, 7]", "expectedOutput": "[7, 7, 7, 7, 7]"}
    ],
    "hints": [
      "Build a map of next greater element for all of nums2.",
      "Use monotonic decreasing stack.",
      "Look up results for nums1 from the map."
    ],
    "solution": "def nextGreaterElement(nums1: list[int], nums2: list[int]) -> list[int]:\n    next_greater = {}\n    stack = []\n    \n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n    \n    return [next_greater.get(num, -1) for num in nums1]"
  }
]
