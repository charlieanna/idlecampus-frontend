[
  {
    "id": "q_295",
    "title": "Find Median from Data Stream",
    "prompt": "Design a data structure that supports addNum(num) and findMedian() for a stream of integers.",
    "constraints": [
      "O(log N) Add",
      "O(1) Find",
      "Two Heaps Pattern"
    ],
    "family_tree": {
      "remedial_id": "q_703",
      "tutorial_id": "t_heap_02"
    },
    "starterCode": "class MedianFinder:\n    def __init__(self):\n        pass\n    \n    def addNum(self, num: int) -> None:\n        pass\n    \n    def findMedian(self) -> float:\n        pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
        "expectedOutput": "[null, null, null, 1.5, null, 2.0]"
      }
    ],
    "hints": [
      "Use max-heap for smaller half, min-heap for larger half.",
      "Balance heaps so size differs by at most 1.",
      "Median is top of larger heap or average of both tops."
    ],
    "solution": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (negate values)\n        self.large = []  # min-heap\n    \n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        \n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2"
  },
  {
    "id": "q_253",
    "title": "Meeting Rooms II",
    "prompt": "Given array of meeting intervals [start, end], return minimum number of conference rooms required.",
    "constraints": [
      "O(N log N) Time",
      "Min-Heap or Sweep Line"
    ],
    "family_tree": {
      "remedial_id": "q_252",
      "tutorial_id": "t_int_02"
    },
    "starterCode": "def minMeetingRooms(intervals: list[list[int]]) -> int:\n    \"\"\"Return minimum rooms needed.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[0, 30], [5, 10], [15, 20]]",
        "expectedOutput": "2"
      },
      {
        "id": "test-2",
        "input": "[[7, 10], [2, 4]]",
        "expectedOutput": "1"
      },
      {
        "id": "test-3",
        "input": "[[1, 5], [2, 3]]",
        "expectedOutput": "2"
      }
    ],
    "hints": [
      "Sort by start time.",
      "Use min-heap to track end times of ongoing meetings.",
      "If new meeting starts after earliest end, reuse that room."
    ],
    "solution": "def minMeetingRooms(intervals: list[list[int]]) -> int:\n    import heapq\n    \n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[0])\n    heap = []  # end times\n    \n    for start, end in intervals:\n        if heap and heap[0] <= start:\n            heapq.heappop(heap)\n        heapq.heappush(heap, end)\n    \n    return len(heap)"
  },
  {
    "id": "q_218",
    "title": "The Skyline Problem",
    "prompt": "Given buildings [left, right, height], return the skyline formed by these buildings collectively.",
    "constraints": [
      "O(N log N) Time",
      "Sweep Line + Max-Heap"
    ],
    "family_tree": {
      "remedial_id": "q_11",
      "tutorial_id": "t_int_02"
    },
    "starterCode": "def getSkyline(buildings: list[list[int]]) -> list[list[int]]:\n    \"\"\"Return skyline as key points.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]",
        "expectedOutput": "[[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]"
      }
    ],
    "hints": [
      "Create events for building start and end.",
      "Use max-heap to track current max height.",
      "Add key point when max height changes."
    ],
    "solution": "def getSkyline(buildings: list[list[int]]) -> list[list[int]]:\n    import heapq\n    \n    events = []\n    for l, r, h in buildings:\n        events.append((l, -h, r))  # start: negative height\n        events.append((r, 0, 0))   # end: height 0\n    \n    events.sort()\n    result = [[0, 0]]\n    heap = [(0, float('inf'))]  # (neg_height, end_x)\n    \n    for x, neg_h, r in events:\n        while heap[0][1] <= x:\n            heapq.heappop(heap)\n        \n        if neg_h:\n            heapq.heappush(heap, (neg_h, r))\n        \n        if result[-1][1] != -heap[0][0]:\n            result.append([x, -heap[0][0]])\n    \n    return result[1:]"
  },
  {
    "id": "q_480",
    "title": "Sliding Window Median",
    "prompt": "Given array nums and window size k, return median for each sliding window.",
    "constraints": [
      "O(N log K) Time",
      "Two Heaps (Lazy Removal)"
    ],
    "family_tree": {
      "remedial_id": "q_295",
      "tutorial_id": "t_heap_02"
    },
    "starterCode": "def medianSlidingWindow(nums: list[int], k: int) -> list[float]:\n    \"\"\"Return medians for each window.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 3, -1, -3, 5, 3, 6, 7], 3",
        "expectedOutput": "[1.0, -1.0, -1.0, 3.0, 5.0, 6.0]"
      },
      {
        "id": "test-2",
        "input": "[1, 2, 3, 4, 2, 3, 1, 4, 2], 3",
        "expectedOutput": "[2.0, 3.0, 3.0, 3.0, 2.0, 3.0, 2.0]"
      }
    ],
    "hints": [
      "Use two heaps like MedianFinder.",
      "For removal, use lazy deletion with a hashmap.",
      "Rebalance heaps considering pending deletions."
    ],
    "solution": "def medianSlidingWindow(nums: list[int], k: int) -> list[float]:\n    from sortedcontainers import SortedList\n    \n    window = SortedList(nums[:k])\n    result = []\n    \n    for i in range(k, len(nums) + 1):\n        if k % 2 == 1:\n            result.append(float(window[k // 2]))\n        else:\n            result.append((window[k // 2 - 1] + window[k // 2]) / 2)\n        \n        if i < len(nums):\n            window.remove(nums[i - k])\n            window.add(nums[i])\n    \n    return result"
  },
  {
    "id": "q_621",
    "title": "Task Scheduler",
    "prompt": "Given tasks array and cooldown n between same tasks, return minimum time to complete all tasks.",
    "constraints": [
      "O(N) Time",
      "Greedy / Math / Max-Heap"
    ],
    "family_tree": {
      "remedial_id": "q_767",
      "tutorial_id": "t_heap_01"
    },
    "starterCode": "def leastInterval(tasks: list[str], n: int) -> int:\n    \"\"\"Return minimum intervals to complete all tasks.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"], 2",
        "expectedOutput": "8"
      },
      {
        "id": "test-2",
        "input": "[\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"], 0",
        "expectedOutput": "6"
      },
      {
        "id": "test-3",
        "input": "[\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"], 2",
        "expectedOutput": "16"
      }
    ],
    "hints": [
      "Most frequent task determines minimum time.",
      "Formula: (max_freq - 1) * (n + 1) + count_of_max_freq.",
      "If tasks fill all slots, answer is just len(tasks)."
    ],
    "solution": "def leastInterval(tasks: list[str], n: int) -> int:\n    from collections import Counter\n    \n    freq = Counter(tasks)\n    max_freq = max(freq.values())\n    max_count = sum(1 for f in freq.values() if f == max_freq)\n    \n    return max(len(tasks), (max_freq - 1) * (n + 1) + max_count)"
  },
  {
    "id": "q_56",
    "title": "Merge Intervals",
    "prompt": "Given array of intervals, merge all overlapping intervals.",
    "constraints": [
      "O(N log N) Time",
      "Sorting + Linear Scan"
    ],
    "family_tree": {
      "remedial_id": "q_57",
      "tutorial_id": "t_int_01"
    },
    "starterCode": "def merge(intervals: list[list[int]]) -> list[list[int]]:\n    \"\"\"Merge overlapping intervals.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[1, 3], [2, 6], [8, 10], [15, 18]]",
        "expectedOutput": "[[1, 6], [8, 10], [15, 18]]"
      },
      {
        "id": "test-2",
        "input": "[[1, 4], [4, 5]]",
        "expectedOutput": "[[1, 5]]"
      },
      {
        "id": "test-3",
        "input": "[[1, 4], [0, 4]]",
        "expectedOutput": "[[0, 4]]"
      }
    ],
    "hints": [
      "Sort by start time.",
      "If current overlaps with last merged, extend the end.",
      "Otherwise, add new interval."
    ],
    "solution": "def merge(intervals: list[list[int]]) -> list[list[int]]:\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    \n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    \n    return merged"
  },
  {
    "id": "q_435",
    "title": "Non-overlapping Intervals",
    "prompt": "Return minimum number of intervals to remove to make the rest non-overlapping.",
    "constraints": [
      "O(N log N) Time",
      "Greedy (Sort by End Time)"
    ],
    "family_tree": {
      "remedial_id": "q_452",
      "tutorial_id": "t_int_03"
    },
    "starterCode": "def eraseOverlapIntervals(intervals: list[list[int]]) -> int:\n    \"\"\"Return minimum removals for non-overlapping.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[1, 2], [2, 3], [3, 4], [1, 3]]",
        "expectedOutput": "1"
      },
      {
        "id": "test-2",
        "input": "[[1, 2], [1, 2], [1, 2]]",
        "expectedOutput": "2"
      },
      {
        "id": "test-3",
        "input": "[[1, 2], [2, 3]]",
        "expectedOutput": "0"
      }
    ],
    "hints": [
      "Sort by end time.",
      "Greedily keep intervals that end earliest.",
      "Count how many we can keep, return total - kept."
    ],
    "solution": "def eraseOverlapIntervals(intervals: list[list[int]]) -> int:\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = float('-inf')\n    \n    for start, end in intervals:\n        if start >= prev_end:\n            count += 1\n            prev_end = end\n    \n    return len(intervals) - count"
  },
  {
    "id": "q_502",
    "title": "IPO",
    "prompt": "Given n projects with profits and required capitals, and initial capital w, find maximum capital after finishing at most k projects.",
    "constraints": [
      "O(N log N) Time",
      "Two Heaps (Min Capital, Max Profit)"
    ],
    "family_tree": {
      "remedial_id": "q_1046",
      "tutorial_id": "t_heap_01"
    },
    "starterCode": "def findMaximizedCapital(k: int, w: int, profits: list[int], capital: list[int]) -> int:\n    \"\"\"Return maximum capital after k projects.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "2, 0, [1, 2, 3], [0, 1, 1]",
        "expectedOutput": "4"
      },
      {
        "id": "test-2",
        "input": "3, 0, [1, 2, 3], [0, 1, 2]",
        "expectedOutput": "6"
      }
    ],
    "hints": [
      "Min-heap for projects by capital requirement.",
      "Max-heap for available projects by profit.",
      "Greedily pick highest profit project we can afford."
    ],
    "solution": "def findMaximizedCapital(k: int, w: int, profits: list[int], capital: list[int]) -> int:\n    import heapq\n    \n    projects = sorted(zip(capital, profits))\n    available = []  # max-heap of profits\n    i = 0\n    \n    for _ in range(k):\n        while i < len(projects) and projects[i][0] <= w:\n            heapq.heappush(available, -projects[i][1])\n            i += 1\n        \n        if not available:\n            break\n        \n        w -= heapq.heappop(available)\n    \n    return w"
  },
  {
    "id": "q_347",
    "title": "Top K Frequent Elements",
    "prompt": "Given integer array nums and k, return the k most frequent elements.",
    "constraints": [
      "O(N log K) Time",
      "Min-Heap / Bucket Sort"
    ],
    "family_tree": {
      "remedial_id": "q_215",
      "tutorial_id": "t_heap_01"
    },
    "starterCode": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n    \"\"\"Return k most frequent elements.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 1, 1, 2, 2, 3], 2",
        "expectedOutput": "[1, 2]"
      },
      {
        "id": "test-2",
        "input": "[1], 1",
        "expectedOutput": "[1]"
      }
    ],
    "hints": [
      "Count frequencies with hashmap.",
      "Use min-heap of size k.",
      "O(N) with bucket sort: index = frequency."
    ],
    "solution": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n    from collections import Counter\n    import heapq\n    \n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)"
  },
  {
    "id": "q_57",
    "title": "Insert Interval",
    "prompt": "Insert new interval into sorted non-overlapping intervals and merge if necessary.",
    "constraints": [
      "O(N) Time",
      "Linear Scan (No Sort needed)"
    ],
    "family_tree": {
      "remedial_id": "q_228",
      "tutorial_id": "t_int_01"
    },
    "starterCode": "def insert(intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:\n    \"\"\"Insert and merge interval.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[1, 3], [6, 9]], [2, 5]",
        "expectedOutput": "[[1, 5], [6, 9]]"
      },
      {
        "id": "test-2",
        "input": "[[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 8]",
        "expectedOutput": "[[1, 2], [3, 10], [12, 16]]"
      },
      {
        "id": "test-3",
        "input": "[], [5, 7]",
        "expectedOutput": "[[5, 7]]"
      }
    ],
    "hints": [
      "Add all intervals ending before new interval starts.",
      "Merge overlapping intervals with new interval.",
      "Add all intervals starting after new interval ends."
    ],
    "solution": "def insert(intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:\n    result = []\n    \n    for i, interval in enumerate(intervals):\n        if interval[1] < newInterval[0]:\n            result.append(interval)\n        elif interval[0] > newInterval[1]:\n            result.append(newInterval)\n            return result + intervals[i:]\n        else:\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\n    \n    result.append(newInterval)\n    return result"
  },
  {
    "id": "q_215",
    "title": "Kth Largest Element in an Array",
    "prompt": "Given an integer array nums and an integer k, return the kth largest element in the array.",
    "constraints": [
      "O(N) Avg Time",
      "QuickSelect or Heap"
    ],
    "family_tree": {
      "remedial_id": "q_703",
      "tutorial_id": "t_heap_01"
    },
    "starterCode": "def findKthLargest(nums: list[int], k: int) -> int:\n    \"\"\"Return kth largest element.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[3, 2, 1, 5, 6, 4], 2",
        "expectedOutput": "5"
      },
      {
        "id": "test-2",
        "input": "[3, 2, 3, 1, 2, 4, 5, 5, 6], 4",
        "expectedOutput": "4"
      }
    ],
    "hints": [
      "Use a min-heap of size k to keep the top k largest elements.",
      "The root of the min-heap will be the kth largest.",
      "Alternatively, use QuickSelect for O(N) average time."
    ],
    "solution": "import heapq\n\ndef findKthLargest(nums: list[int], k: int) -> int:\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap[0]"
  },
  {
    "id": "q_1057",
    "title": "Campus Bikes",
    "prompt": "On a campus with n workers and m bikes, assign each worker to the nearest bike. Use Manhattan distance.",
    "constraints": [
      "O(N*M) Time",
      "Bucket Sort / Heap"
    ],
    "family_tree": {
      "remedial_id": "q_973",
      "tutorial_id": "t_heap_02"
    },
    "starterCode": "def assignBikes(workers: list[list[int]], bikes: list[list[int]]) -> list[int]:\n    \"\"\"Assign workers to nearest bikes.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[0,0],[2,1]], [[1,2],[3,3]]",
        "expectedOutput": "[1, 0]"
      },
      {
        "id": "test-2",
        "input": "[[0,0],[1,1],[2,0]], [[1,0],[2,2],[2,1]]",
        "expectedOutput": "[0, 2, 1]"
      }
    ],
    "hints": [
      "Calculate all pairs of (distance, worker_index, bike_index).",
      "Sort pairs by distance, then worker index, then bike index.",
      "Assign greedily if worker and bike are unassigned."
    ],
    "solution": "def assignBikes(workers: list[list[int]], bikes: list[list[int]]) -> list[int]:\n    distances = []\n    for i, w in enumerate(workers):\n        for j, b in enumerate(bikes):\n            dist = abs(w[0] - b[0]) + abs(w[1] - b[1])\n            distances.append((dist, i, j))\n            \n    distances.sort()\n    \n    result = [-1] * len(workers)\n    used_bikes = set()\n    \n    for _, w_idx, b_idx in distances:\n        if result[w_idx] == -1 and b_idx not in used_bikes:\n            result[w_idx] = b_idx\n            used_bikes.add(b_idx)\n            \n    return result"
  },
  {
    "id": "q_658",
    "title": "Find K Closest Elements",
    "prompt": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.",
    "constraints": [
      "O(log N + k) Time",
      "Binary Search + Two Pointers"
    ],
    "family_tree": {
      "remedial_id": "q_704",
      "tutorial_id": "t_arr_03"
    },
    "starterCode": "def findClosestElements(arr: list[int], k: int, x: int) -> list[int]:\n    \"\"\"Return k closest elements to x.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 2, 3, 4, 5], 4, 3",
        "expectedOutput": "[1, 2, 3, 4]"
      },
      {
        "id": "test-2",
        "input": "[1, 2, 3, 4, 5], 4, -1",
        "expectedOutput": "[1, 2, 3, 4]"
      }
    ],
    "hints": [
      "Binary search to find the closest element to x.",
      "Use two pointers expanding from that position.",
      "Alternatively, use binary search to find the left bound of the window size k."
    ],
    "solution": "def findClosestElements(arr: list[int], k: int, x: int) -> list[int]:\n    l, r = 0, len(arr) - k\n    \n    while l < r:\n        mid = (l + r) // 2\n        if x - arr[mid] > arr[mid + k] - x:\n            l = mid + 1\n        else:\n            r = mid\n            \n    return arr[l : l + k]"
  },
  {
    "id": "q_846",
    "title": "Hand of Straights",
    "prompt": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards. Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",
    "constraints": [
      "O(N log N) Time",
      "TreeMap / MinHeap"
    ],
    "family_tree": {
      "remedial_id": "q_215",
      "tutorial_id": "t_heap_01"
    },
    "starterCode": "def isNStraightHand(hand: list[int], groupSize: int) -> bool:\n    \"\"\"Return True if valid grouping is possible.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1,2,3,6,2,3,4,7,8], 3",
        "expectedOutput": "true"
      },
      {
        "id": "test-2",
        "input": "[1,2,3,4,5], 4",
        "expectedOutput": "false"
      }
    ],
    "hints": [
      "Count card frequencies.",
      "Process cards in sorted order.",
      "Try to form groups starting from smallest available card."
    ],
    "solution": "import collections\nimport heapq\ndef isNStraightHand(hand: list[int], groupSize: int) -> bool:\n    if len(hand) % groupSize != 0:\n        return False\n    count = collections.Counter(hand)\n    min_heap = list(count.keys())\n    heapq.heapify(min_heap)\n    \n    while min_heap:\n        first = min_heap[0]\n        for i in range(first, first + groupSize):\n            if count[i] == 0:\n                return False\n            count[i] -= 1\n            if count[i] == 0:\n                if i != min_heap[0]:\n                    return False # Must remove min element first\n                heapq.heappop(min_heap)\n    return True"
  },
  {
    "id": "q_986",
    "title": "Interval List Intersections",
    "prompt": "You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists.",
    "constraints": [
      "O(N + M) Time",
      "Two Pointers"
    ],
    "family_tree": {
      "remedial_id": "q_56",
      "tutorial_id": "t_heap_02"
    },
    "starterCode": "def intervalIntersection(firstList: list[list[int]], secondList: list[list[int]]) -> list[list[int]]:\n    \"\"\"Return intersection of intervals.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[0,2],[5,10],[13,23],[24,25]], [[1,5],[8,12],[15,24],[25,26]]",
        "expectedOutput": "[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]"
      },
      {
        "id": "test-2",
        "input": "[[1,3],[5,9]], []",
        "expectedOutput": "[]"
      }
    ],
    "hints": [
      "Use two pointers i and j.",
      "Intersection is [max(start1, start2), min(end1, end2)].",
      "If start > end, no intersection.",
      "Move pointer with smaller end time."
    ],
    "solution": "def intervalIntersection(firstList: list[list[int]], secondList: list[list[int]]) -> list[list[int]]:\n    i = j = 0\n    res = []\n    while i < len(firstList) and j < len(secondList):\n        lo = max(firstList[i][0], secondList[j][0])\n        hi = min(firstList[i][1], secondList[j][1])\n        \n        if lo <= hi:\n            res.append([lo, hi])\n            \n        if firstList[i][1] < secondList[j][1]:\n            i += 1\n        else:\n            j += 1\n    return res"
  }
]