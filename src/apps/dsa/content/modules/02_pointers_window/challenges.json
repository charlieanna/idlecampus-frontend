[
  {
    "id": "q_42",
    "title": "Trapping Rain Water",
    "prompt": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "constraints": ["O(N) Time", "O(1) Space"],
    "family_tree": {"remedial_id": "q_11", "tutorial_id": "t_ptr_03"},
    "starterCode": "def trap(height: list[int]) -> int:\n    \"\"\"Calculate how much water can be trapped.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]", "expectedOutput": "6"},
      {"id": "test-2", "input": "[4, 2, 0, 3, 2, 5]", "expectedOutput": "9"},
      {"id": "test-3", "input": "[1, 2, 3, 4, 5]", "expectedOutput": "0"}
    ],
    "hints": [
      "Water at each position = min(max_left, max_right) - height[i].",
      "Use two pointers from both ends, tracking max heights on each side.",
      "Process the side with the smaller max first."
    ],
    "solution": "def trap(height: list[int]) -> int:\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max, right_max = height[left], height[right]\n    water = 0\n    \n    while left < right:\n        if left_max < right_max:\n            left += 1\n            left_max = max(left_max, height[left])\n            water += left_max - height[left]\n        else:\n            right -= 1\n            right_max = max(right_max, height[right])\n            water += right_max - height[right]\n    \n    return water"
  },
  {
    "id": "q_76",
    "title": "Minimum Window Substring",
    "prompt": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. Return empty string if no such window exists.",
    "constraints": ["O(N) Time", "O(1) Space (Char Map)"],
    "family_tree": {"remedial_id": "q_567", "tutorial_id": "t_win_02"},
    "starterCode": "def minWindow(s: str, t: str) -> str:\n    \"\"\"Return minimum window substring containing all chars of t.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "\"ADOBECODEBANC\", \"ABC\"", "expectedOutput": "\"BANC\""},
      {"id": "test-2", "input": "\"a\", \"a\"", "expectedOutput": "\"a\""},
      {"id": "test-3", "input": "\"a\", \"aa\"", "expectedOutput": "\"\""}
    ],
    "hints": [
      "Use a sliding window with two pointers.",
      "Expand right to include all characters, then shrink left to minimize.",
      "Track character counts needed vs. counts in current window."
    ],
    "solution": "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    \n    if not t or not s:\n        return \"\"\n    \n    need = Counter(t)\n    have = {}\n    required = len(need)\n    formed = 0\n    \n    left = 0\n    min_len = float('inf')\n    min_window = \"\"\n    \n    for right, char in enumerate(s):\n        have[char] = have.get(char, 0) + 1\n        \n        if char in need and have[char] == need[char]:\n            formed += 1\n        \n        while formed == required:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right + 1]\n            \n            left_char = s[left]\n            have[left_char] -= 1\n            if left_char in need and have[left_char] < need[left_char]:\n                formed -= 1\n            left += 1\n    \n    return min_window"
  },
  {
    "id": "q_15",
    "title": "3Sum",
    "prompt": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. The solution set must not contain duplicate triplets.",
    "constraints": ["O(N^2) Time", "No Duplicates"],
    "family_tree": {"remedial_id": "q_167", "tutorial_id": "t_ptr_02"},
    "starterCode": "def threeSum(nums: list[int]) -> list[list[int]]:\n    \"\"\"Return all unique triplets that sum to zero.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[-1, 0, 1, 2, -1, -4]", "expectedOutput": "[[-1, -1, 2], [-1, 0, 1]]"},
      {"id": "test-2", "input": "[0, 1, 1]", "expectedOutput": "[]"},
      {"id": "test-3", "input": "[0, 0, 0]", "expectedOutput": "[[0, 0, 0]]"}
    ],
    "hints": [
      "Sort the array first to enable two-pointer technique.",
      "Fix one element, then use two pointers for the remaining two.",
      "Skip duplicates to avoid duplicate triplets."
    ],
    "solution": "def threeSum(nums: list[int]) -> list[list[int]]:\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            \n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    \n    return result"
  },
  {
    "id": "q_11",
    "title": "Container With Most Water",
    "prompt": "Given n non-negative integers height[i] representing heights at positions, find two lines that together with the x-axis form a container that holds the most water.",
    "constraints": ["O(N) Time", "Greedy Approach"],
    "family_tree": {"remedial_id": "q_125", "tutorial_id": "t_ptr_01"},
    "starterCode": "def maxArea(height: list[int]) -> int:\n    \"\"\"Return the maximum area of water a container can store.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 8, 6, 2, 5, 4, 8, 3, 7]", "expectedOutput": "49"},
      {"id": "test-2", "input": "[1, 1]", "expectedOutput": "1"},
      {"id": "test-3", "input": "[4, 3, 2, 1, 4]", "expectedOutput": "16"}
    ],
    "hints": [
      "Area = width * min(height[left], height[right]).",
      "Start with widest container (both ends).",
      "Move the shorter line inward (only way to potentially find larger area)."
    ],
    "solution": "def maxArea(height: list[int]) -> int:\n    left, right = 0, len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        width = right - left\n        h = min(height[left], height[right])\n        max_area = max(max_area, width * h)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area"
  },
  {
    "id": "q_239",
    "title": "Sliding Window Maximum",
    "prompt": "Given an array nums and sliding window size k, return the max value in each window as the window slides from left to right.",
    "constraints": ["O(N) Time", "Monotonic Deque"],
    "family_tree": {"remedial_id": "q_121", "tutorial_id": "t_win_03"},
    "starterCode": "def maxSlidingWindow(nums: list[int], k: int) -> list[int]:\n    \"\"\"Return array of max values for each sliding window.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 3, -1, -3, 5, 3, 6, 7], 3", "expectedOutput": "[3, 3, 5, 5, 6, 7]"},
      {"id": "test-2", "input": "[1], 1", "expectedOutput": "[1]"},
      {"id": "test-3", "input": "[9, 11], 2", "expectedOutput": "[11]"}
    ],
    "hints": [
      "Use a monotonic decreasing deque to track potential maximums.",
      "Remove indices that are out of window from front.",
      "Remove smaller elements from back before adding new element."
    ],
    "solution": "def maxSlidingWindow(nums: list[int], k: int) -> list[int]:\n    from collections import deque\n    \n    dq = deque()  # stores indices\n    result = []\n    \n    for i, num in enumerate(nums):\n        # Remove indices outside window\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        \n        # Remove smaller elements from back\n        while dq and nums[dq[-1]] < num:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add to result once window is complete\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result"
  },
  {
    "id": "q_424",
    "title": "Longest Repeating Character Replacement",
    "prompt": "Given string s and integer k, you can change at most k characters to any other character. Return the length of the longest substring with all same characters.",
    "constraints": ["O(N) Time", "Valid Window logic"],
    "family_tree": {"remedial_id": "q_3", "tutorial_id": "t_win_02"},
    "starterCode": "def characterReplacement(s: str, k: int) -> int:\n    \"\"\"Return longest substring with same chars after at most k changes.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "\"ABAB\", 2", "expectedOutput": "4"},
      {"id": "test-2", "input": "\"AABABBA\", 1", "expectedOutput": "4"},
      {"id": "test-3", "input": "\"A\", 0", "expectedOutput": "1"}
    ],
    "hints": [
      "Window is valid if: window_size - max_freq <= k.",
      "Track frequency of each character in current window.",
      "Shrink window when it becomes invalid."
    ],
    "solution": "def characterReplacement(s: str, k: int) -> int:\n    count = {}\n    max_freq = 0\n    left = 0\n    result = 0\n    \n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_freq = max(max_freq, count[s[right]])\n        \n        # Window size - max_freq = chars to replace\n        while (right - left + 1) - max_freq > k:\n            count[s[left]] -= 1\n            left += 1\n        \n        result = max(result, right - left + 1)\n    \n    return result"
  },
  {
    "id": "q_340",
    "title": "Longest Substring with At Most K Distinct Characters",
    "prompt": "Given a string s and an integer k, return the length of the longest substring that contains at most k distinct characters.",
    "constraints": ["O(N) Time", "HashMap Tracking"],
    "family_tree": {"remedial_id": "q_3", "tutorial_id": "t_win_02"},
    "starterCode": "def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int:\n    \"\"\"Return longest substring with at most k distinct chars.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "\"eceba\", 2", "expectedOutput": "3"},
      {"id": "test-2", "input": "\"aa\", 1", "expectedOutput": "2"},
      {"id": "test-3", "input": "\"a\", 0", "expectedOutput": "0"}
    ],
    "hints": [
      "Use sliding window with a hashmap to track character counts.",
      "When distinct chars exceed k, shrink from left.",
      "Remove character from map when its count reaches 0."
    ],
    "solution": "def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int:\n    if k == 0:\n        return 0\n    \n    char_count = {}\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        \n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        max_len = max(max_len, right - left + 1)\n    \n    return max_len"
  },
  {
    "id": "q_18",
    "title": "4Sum",
    "prompt": "Given array nums of n integers and target, return all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] that sum to target.",
    "constraints": ["O(N^3) Time", "Generalized kSum"],
    "family_tree": {"remedial_id": "q_15", "tutorial_id": "t_ptr_02"},
    "starterCode": "def fourSum(nums: list[int], target: int) -> list[list[int]]:\n    \"\"\"Return all unique quadruplets that sum to target.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 0, -1, 0, -2, 2], 0", "expectedOutput": "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]"},
      {"id": "test-2", "input": "[2, 2, 2, 2, 2], 8", "expectedOutput": "[[2, 2, 2, 2]]"},
      {"id": "test-3", "input": "[1, 2, 3, 4], 100", "expectedOutput": "[]"}
    ],
    "hints": [
      "Sort array first.",
      "Fix first two elements with nested loops, use two pointers for remaining two.",
      "Skip duplicates at each level."
    ],
    "solution": "def fourSum(nums: list[int], target: int) -> list[list[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n    \n    for i in range(n - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, n - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            \n            left, right = j + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n    \n    return result"
  },
  {
    "id": "q_75",
    "title": "Sort Colors",
    "prompt": "Given array with n objects colored red (0), white (1), or blue (2), sort them in-place so same colors are adjacent in order 0, 1, 2.",
    "constraints": ["O(N) Time", "O(1) Space", "One Pass"],
    "family_tree": {"remedial_id": "q_283", "tutorial_id": "t_ptr_04"},
    "starterCode": "def sortColors(nums: list[int]) -> None:\n    \"\"\"Sort array with 0s, 1s, 2s in-place.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[2, 0, 2, 1, 1, 0]", "expectedOutput": "[0, 0, 1, 1, 2, 2]"},
      {"id": "test-2", "input": "[2, 0, 1]", "expectedOutput": "[0, 1, 2]"},
      {"id": "test-3", "input": "[0]", "expectedOutput": "[0]"}
    ],
    "hints": [
      "Dutch National Flag algorithm: three-way partitioning.",
      "Use three pointers: low (0s boundary), mid (current), high (2s boundary).",
      "Swap 0s to low, 2s to high, skip 1s."
    ],
    "solution": "def sortColors(nums: list[int]) -> None:\n    low, mid, high = 0, 0, len(nums) - 1\n    \n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1"
  },
  {
    "id": "q_84",
    "title": "Largest Rectangle in Histogram",
    "prompt": "Given array of integers representing histogram bar heights (width = 1 each), return the area of the largest rectangle in the histogram.",
    "constraints": ["O(N) Time", "Stack/Two Pointers refined"],
    "family_tree": {"remedial_id": "q_11", "tutorial_id": "t_ptr_05"},
    "starterCode": "def largestRectangleArea(heights: list[int]) -> int:\n    \"\"\"Return largest rectangle area in histogram.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[2, 1, 5, 6, 2, 3]", "expectedOutput": "10"},
      {"id": "test-2", "input": "[2, 4]", "expectedOutput": "4"},
      {"id": "test-3", "input": "[1]", "expectedOutput": "1"}
    ],
    "hints": [
      "Use a monotonic increasing stack to track bar indices.",
      "When a shorter bar is found, calculate areas for all taller bars in stack.",
      "Width extends from previous stack element to current position."
    ],
    "solution": "def largestRectangleArea(heights: list[int]) -> int:\n    stack = []  # stores indices\n    max_area = 0\n    heights.append(0)  # sentinel to pop all remaining bars\n    \n    for i, h in enumerate(heights):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    \n    heights.pop()  # restore original array\n    return max_area"
  }
]
