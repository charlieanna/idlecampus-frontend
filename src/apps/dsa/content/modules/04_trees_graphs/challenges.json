[
  {
    "id": "q_269",
    "title": "Alien Dictionary",
    "prompt": "Given a list of strings sorted lexicographically by the rules of an alien language, return a string of the unique letters sorted by the alien language's rules. Return empty string if invalid.",
    "constraints": [
      "O(C) Time (Total chars)",
      "Topological Sort"
    ],
    "family_tree": {
      "remedial_id": "q_210",
      "tutorial_id": "t_graph_02"
    },
    "starterCode": "def alienOrder(words: list[str]) -> str:\n    \"\"\"Return alien alphabet order.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]",
        "expectedOutput": "\"wertf\""
      },
      {
        "id": "test-2",
        "input": "[\"z\", \"x\"]",
        "expectedOutput": "\"zx\""
      },
      {
        "id": "test-3",
        "input": "[\"z\", \"x\", \"z\"]",
        "expectedOutput": "\"\""
      }
    ],
    "hints": [
      "Build a graph: compare adjacent words to find ordering constraints.",
      "Use topological sort (BFS with indegree or DFS) to find valid order.",
      "Detect cycle = invalid ordering."
    ],
    "solution": "def alienOrder(words: list[str]) -> str:\n    from collections import defaultdict, deque\n    \n    # Build graph\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n    \n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        min_len = min(len(w1), len(w2))\n        \n        # Invalid: prefix comes after longer word\n        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n            return \"\"\n        \n        for j in range(min_len):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n    \n    # Topological sort (BFS)\n    queue = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n    \n    while queue:\n        char = queue.popleft()\n        result.append(char)\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return ''.join(result) if len(result) == len(indegree) else \"\""
  },
  {
    "id": "q_126",
    "title": "Word Ladder II",
    "prompt": "Find all shortest transformation sequences from beginWord to endWord, where each adjacent pair differs by exactly one letter. Return all shortest sequences.",
    "constraints": [
      "O(N*L^2) Time",
      "BFS + Backtracking"
    ],
    "family_tree": {
      "remedial_id": "q_127",
      "tutorial_id": "t_graph_01"
    },
    "starterCode": "def findLadders(beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n    \"\"\"Return all shortest transformation sequences.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]",
        "expectedOutput": "[[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"]]"
      },
      {
        "id": "test-2",
        "input": "\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]",
        "expectedOutput": "[]"
      }
    ],
    "hints": [
      "BFS to find shortest path length and build parent pointers.",
      "Backtrack from endWord using parent pointers to build all paths.",
      "Only add edges that lead to shorter paths (level by level)."
    ],
    "solution": "def findLadders(beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n    from collections import defaultdict, deque\n    \n    wordSet = set(wordList)\n    if endWord not in wordSet:\n        return []\n    \n    # BFS to build parent map\n    parents = defaultdict(set)\n    level = {beginWord}\n    found = False\n    \n    while level and not found:\n        wordSet -= level\n        next_level = set()\n        \n        for word in level:\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        next_level.add(new_word)\n                        parents[new_word].add(word)\n                    if new_word == endWord:\n                        found = True\n        \n        level = next_level\n    \n    # Backtrack to build paths\n    def backtrack(word):\n        if word == beginWord:\n            return [[beginWord]]\n        return [[*path, word] for parent in parents[word] for path in backtrack(parent)]\n    \n    return backtrack(endWord) if found else []"
  },
  {
    "id": "q_124",
    "title": "Binary Tree Maximum Path Sum",
    "prompt": "Find the maximum path sum in a binary tree. A path is any sequence of nodes connected by edges, not necessarily through root.",
    "constraints": [
      "O(N) Time",
      "DFS + Global Max"
    ],
    "family_tree": {
      "remedial_id": "q_543",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    \"\"\"Return maximum path sum.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 2, 3]",
        "expectedOutput": "6"
      },
      {
        "id": "test-2",
        "input": "[-10, 9, 20, null, null, 15, 7]",
        "expectedOutput": "42"
      },
      {
        "id": "test-3",
        "input": "[-3]",
        "expectedOutput": "-3"
      }
    ],
    "hints": [
      "At each node, max path through it = node.val + max(left, 0) + max(right, 0).",
      "Return value to parent = node.val + max(left, right, 0) (can only extend one way).",
      "Track global maximum separately."
    ],
    "solution": "def maxPathSum(root: TreeNode) -> int:\n    max_sum = float('-inf')\n    \n    def dfs(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        left = max(dfs(node.left), 0)\n        right = max(dfs(node.right), 0)\n        \n        # Path through this node\n        max_sum = max(max_sum, node.val + left + right)\n        \n        # Return max path extending upward\n        return node.val + max(left, right)\n    \n    dfs(root)\n    return max_sum"
  },
  {
    "id": "q_297",
    "title": "Serialize and Deserialize Binary Tree",
    "prompt": "Design an algorithm to serialize and deserialize a binary tree. Convert tree to string and back to the original structure.",
    "constraints": [
      "O(N) Time",
      "Preorder/Level-order"
    ],
    "family_tree": {
      "remedial_id": "q_105",
      "tutorial_id": "t_tree_01"
    },
    "starterCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root: TreeNode) -> str:\n        \"\"\"Encode tree to string.\"\"\"\n        pass\n    \n    def deserialize(self, data: str) -> TreeNode:\n        \"\"\"Decode string to tree.\"\"\"\n        pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 2, 3, null, null, 4, 5]",
        "expectedOutput": "[1, 2, 3, null, null, 4, 5]"
      },
      {
        "id": "test-2",
        "input": "[]",
        "expectedOutput": "[]"
      }
    ],
    "hints": [
      "Use preorder traversal with null markers.",
      "Serialize: recursively write value or 'null' for None.",
      "Deserialize: use iterator/queue to rebuild tree recursively."
    ],
    "solution": "class Codec:\n    def serialize(self, root: TreeNode) -> str:\n        def preorder(node):\n            if not node:\n                return ['null']\n            return [str(node.val)] + preorder(node.left) + preorder(node.right)\n        \n        return ','.join(preorder(root))\n    \n    def deserialize(self, data: str) -> TreeNode:\n        def build(nodes):\n            val = next(nodes)\n            if val == 'null':\n                return None\n            node = TreeNode(int(val))\n            node.left = build(nodes)\n            node.right = build(nodes)\n            return node\n        \n        return build(iter(data.split(',')))"
  },
  {
    "id": "q_210",
    "title": "Course Schedule II",
    "prompt": "Return the ordering of courses to finish all courses given prerequisites. If impossible, return empty array.",
    "constraints": [
      "O(V+E) Time",
      "Topological Sort"
    ],
    "family_tree": {
      "remedial_id": "q_207",
      "tutorial_id": "t_graph_02"
    },
    "starterCode": "def findOrder(numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n    \"\"\"Return valid course order.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "2, [[1, 0]]",
        "expectedOutput": "[0, 1]"
      },
      {
        "id": "test-2",
        "input": "4, [[1, 0], [2, 0], [3, 1], [3, 2]]",
        "expectedOutput": "[0, 1, 2, 3]"
      },
      {
        "id": "test-3",
        "input": "1, []",
        "expectedOutput": "[0]"
      }
    ],
    "hints": [
      "Build graph and track indegree of each node.",
      "BFS: start with nodes having indegree 0.",
      "If result has fewer nodes than total, there's a cycle."
    ],
    "solution": "def findOrder(numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n    from collections import defaultdict, deque\n    \n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        indegree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n    result = []\n    \n    while queue:\n        course = queue.popleft()\n        result.append(course)\n        \n        for next_course in graph[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n    \n    return result if len(result) == numCourses else []"
  },
  {
    "id": "q_261",
    "title": "Graph Valid Tree",
    "prompt": "Given n nodes and edges, determine if the graph forms a valid tree (connected, no cycles).",
    "constraints": [
      "O(V+E) Time",
      "Union Find / DFS"
    ],
    "family_tree": {
      "remedial_id": "q_323",
      "tutorial_id": "t_graph_03"
    },
    "starterCode": "def validTree(n: int, edges: list[list[int]]) -> bool:\n    \"\"\"Return True if edges form a valid tree.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "5, [[0, 1], [0, 2], [0, 3], [1, 4]]",
        "expectedOutput": "true"
      },
      {
        "id": "test-2",
        "input": "5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]",
        "expectedOutput": "false"
      },
      {
        "id": "test-3",
        "input": "5, [[0, 1], [2, 3]]",
        "expectedOutput": "false"
      }
    ],
    "hints": [
      "Tree has exactly n-1 edges and is connected.",
      "Use Union-Find: if adding edge would connect already-connected nodes, there's a cycle.",
      "Or use DFS: visit all nodes, check for back edges."
    ],
    "solution": "def validTree(n: int, edges: list[list[int]]) -> bool:\n    if len(edges) != n - 1:\n        return False\n    \n    # Union Find\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False  # Cycle detected\n        parent[px] = py\n        return True\n    \n    for u, v in edges:\n        if not union(u, v):\n            return False\n    \n    return True"
  },
  {
    "id": "q_787",
    "title": "Cheapest Flights Within K Stops",
    "prompt": "Find cheapest price from src to dst with at most k stops. Return -1 if no such route exists.",
    "constraints": [
      "O((V+E)K) Time",
      "Bellman-Ford / BFS"
    ],
    "family_tree": {
      "remedial_id": "q_743",
      "tutorial_id": "t_graph_01"
    },
    "starterCode": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    \"\"\"Return cheapest price with at most k stops.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "4, [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]], 0, 3, 1",
        "expectedOutput": "700"
      },
      {
        "id": "test-2",
        "input": "3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1",
        "expectedOutput": "200"
      },
      {
        "id": "test-3",
        "input": "3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 0",
        "expectedOutput": "500"
      }
    ],
    "hints": [
      "Use modified Bellman-Ford: iterate k+1 times.",
      "Or BFS level by level, stopping at k+1 levels.",
      "Track minimum cost to reach each node at each level."
    ],
    "solution": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    # Bellman-Ford with k+1 iterations\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    for _ in range(k + 1):\n        temp = prices.copy()\n        for u, v, price in flights:\n            if prices[u] != float('inf'):\n                temp[v] = min(temp[v], prices[u] + price)\n        prices = temp\n    \n    return prices[dst] if prices[dst] != float('inf') else -1"
  },
  {
    "id": "q_105",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "prompt": "Given preorder and inorder traversal arrays, construct and return the binary tree.",
    "constraints": [
      "O(N) Time",
      "Recursive Partitioning"
    ],
    "family_tree": {
      "remedial_id": "q_106",
      "tutorial_id": "t_tree_01"
    },
    "starterCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(preorder: list[int], inorder: list[int]) -> TreeNode:\n    \"\"\"Build tree from preorder and inorder.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[3, 9, 20, 15, 7], [9, 3, 15, 20, 7]",
        "expectedOutput": "[3, 9, 20, null, null, 15, 7]"
      },
      {
        "id": "test-2",
        "input": "[-1], [-1]",
        "expectedOutput": "[-1]"
      }
    ],
    "hints": [
      "Preorder first element is always the root.",
      "Find root in inorder to determine left/right subtree sizes.",
      "Use hashmap for O(1) lookup in inorder."
    ],
    "solution": "def buildTree(preorder: list[int], inorder: list[int]) -> TreeNode:\n    inorder_map = {val: idx for idx, val in enumerate(inorder)}\n    \n    def build(pre_start, pre_end, in_start, in_end):\n        if pre_start > pre_end:\n            return None\n        \n        root_val = preorder[pre_start]\n        root = TreeNode(root_val)\n        \n        in_root = inorder_map[root_val]\n        left_size = in_root - in_start\n        \n        root.left = build(pre_start + 1, pre_start + left_size, in_start, in_root - 1)\n        root.right = build(pre_start + left_size + 1, pre_end, in_root + 1, in_end)\n        \n        return root\n    \n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)"
  },
  {
    "id": "q_332",
    "title": "Reconstruct Itinerary",
    "prompt": "Given flight tickets [from, to], reconstruct the itinerary starting from 'JFK'. If multiple valid itineraries, return the lexically smallest.",
    "constraints": [
      "O(E log E) Time",
      "Eulerian Path / Hierholzer's"
    ],
    "family_tree": {
      "remedial_id": "q_797",
      "tutorial_id": "t_graph_01"
    },
    "starterCode": "def findItinerary(tickets: list[list[str]]) -> list[str]:\n    \"\"\"Return itinerary starting from JFK.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]",
        "expectedOutput": "[\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]"
      },
      {
        "id": "test-2",
        "input": "[[\"JFK\", \"SFO\"], [\"JFK\", \"ATL\"], [\"SFO\", \"ATL\"], [\"ATL\", \"JFK\"], [\"ATL\", \"SFO\"]]",
        "expectedOutput": "[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]"
      }
    ],
    "hints": [
      "Build graph with sorted destinations (for lexical order).",
      "Hierholzer's algorithm: DFS, add to result when backtracking.",
      "Reverse the result at the end."
    ],
    "solution": "def findItinerary(tickets: list[list[str]]) -> list[str]:\n    from collections import defaultdict\n    \n    graph = defaultdict(list)\n    for src, dst in sorted(tickets, reverse=True):\n        graph[src].append(dst)\n    \n    result = []\n    \n    def dfs(airport):\n        while graph[airport]:\n            dfs(graph[airport].pop())\n        result.append(airport)\n    \n    dfs('JFK')\n    return result[::-1]"
  },
  {
    "id": "q_236",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "prompt": "Find the lowest common ancestor (LCA) of two given nodes p and q in a binary tree.",
    "constraints": [
      "O(N) Time",
      "Recursive DFS"
    ],
    "family_tree": {
      "remedial_id": "q_235",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    \"\"\"Find LCA of p and q.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], 5, 1",
        "expectedOutput": "3"
      },
      {
        "id": "test-2",
        "input": "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], 5, 4",
        "expectedOutput": "5"
      }
    ],
    "hints": [
      "If current node is p or q, return it.",
      "Recursively search left and right subtrees.",
      "If both return non-null, current node is LCA."
    ],
    "solution": "def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    if not root or root == p or root == q:\n        return root\n    \n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    \n    if left and right:\n        return root\n    \n    return left if left else right"
  },
  {
    "id": "q_285",
    "title": "Inorder Successor in BST",
    "prompt": "Given the root of a binary search tree and a node p in it, return the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null.",
    "constraints": [
      "O(H) Time",
      "BST Properties"
    ],
    "family_tree": {
      "remedial_id": "q_700",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "def inorderSuccessor(root: TreeNode, p: TreeNode) -> TreeNode:\n    \"\"\"Return inorder successor.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[2, 1, 3], 1",
        "expectedOutput": "2"
      },
      {
        "id": "test-2",
        "input": "[5, 3, 6, 2, 4, null, null, 1], 6",
        "expectedOutput": "null"
      }
    ],
    "hints": [
      "If p has a right child, successor is the leftmost node in right subtree.",
      "Otherwise, successor is one of the ancestors.",
      "Use BST property: if p.val < root.val, successor is in left subtree or is root."
    ],
    "solution": "def inorderSuccessor(root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':\n    successor = None\n    while root:\n        if p.val < root.val:\n            successor = root\n            root = root.left\n        else:\n            root = root.right\n    return successor"
  },
  {
    "id": "q_938",
    "title": "Range Sum of BST",
    "prompt": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].",
    "constraints": [
      "O(N) Time",
      "DFS"
    ],
    "family_tree": {
      "remedial_id": "q_700",
      "tutorial_id": "t_tree_01"
    },
    "starterCode": "def rangeSumBST(root: TreeNode, low: int, high: int) -> int:\n    \"\"\"Return sum of nodes in range.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[10, 5, 15, 3, 7, null, 18], 7, 15",
        "expectedOutput": "32"
      },
      {
        "id": "test-2",
        "input": "[10, 5, 15, 3, 7, 13, 18, 1, null, 6], 6, 10",
        "expectedOutput": "23"
      }
    ],
    "hints": [
      "Use DFS or BFS.",
      "If node.val < low, prune left child.",
      "If node.val > high, prune right child."
    ],
    "solution": "def rangeSumBST(root: TreeNode, low: int, high: int) -> int:\n    def dfs(node):\n        if not node:\n            return 0\n        total = 0\n        if low <= node.val <= high:\n            total += node.val\n        if node.val > low:\n            total += dfs(node.left)\n        if node.val < high:\n            total += dfs(node.right)\n        return total\n    \n    return dfs(root)"
  },
  {
    "id": "q_1145",
    "title": "Binary Tree Coloring Game",
    "prompt": "Two players play a game on a binary tree. First player picks a node 'n', second player picks a node 'x'. Return true if second player can win by coloring more nodes.",
    "constraints": [
      "O(N) Time",
      "Tree Counting"
    ],
    "family_tree": {
      "remedial_id": "q_104",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "def btreeGameWinningMove(root: TreeNode, n: int, x: int) -> bool:\n    \"\"\"Return True if player 2 can win.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 11, 3",
        "expectedOutput": "true"
      }
    ],
    "hints": [
      "Player 2 chooses a neighbor of x: left child, right child, or parent.",
      "Count nodes in left subtree of x, right subtree of x.",
      "Nodes in parent's side = n - (left + right + 1)."
    ],
    "solution": "def btreeGameWinningMove(root: TreeNode, n: int, x: int) -> bool:\n    left_count = 0\n    right_count = 0\n    \n    def count(node):\n        nonlocal left_count, right_count\n        if not node:\n            return 0\n        l = count(node.left)\n        r = count(node.right)\n        if node.val == x:\n            left_count = l\n            right_count = r\n        return l + r + 1\n        \n    count(root)\n    parent_count = n - (left_count + right_count + 1)\n    return max(parent_count, left_count, right_count) > n // 2"
  },
  {
    "id": "q_721",
    "title": "Accounts Merge",
    "prompt": "Given a list of accounts where each element is a list of strings, the first element is a name, and the rest are emails. Merge accounts that share an email.",
    "constraints": [
      "O(N*K log NK) Time",
      "Union Find"
    ],
    "family_tree": {
      "remedial_id": "q_323",
      "tutorial_id": "t_graph_03"
    },
    "starterCode": "def accountsMerge(accounts: list[list[str]]) -> list[list[str]]:\n    \"\"\"Merge accounts.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
        "expectedOutput": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]"
      }
    ],
    "hints": [
      "Use Union-Find to connect emails.",
      "Map each email to an ID or parent email.",
      "Group emails by their root parent."
    ],
    "solution": "def accountsMerge(accounts: list[list[str]]) -> list[list[str]]:\n    from collections import defaultdict\n    \n    email_to_name = {}\n    parent = {}\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        parent[find(x)] = find(y)\n        \n    for acc in accounts:\n        name = acc[0]\n        if not acc[1:]:\n            continue\n        root_email = acc[1]\n        for email in acc[1:]:\n            if email not in parent:\n                parent[email] = email\n            email_to_name[email] = name\n            union(root_email, email)\n            \n    components = defaultdict(list)\n    for email in parent:\n        components[find(email)].append(email)\n        \n    return [[email_to_name[root]] + sorted(emails) for root, emails in components.items()]"
  },
  {
    "id": "q_803",
    "title": "Bricks Falling When Hit",
    "prompt": "Given an m x n grid of bricks (1) and empty spaces (0), and a list of hits. Bricks drop if they are no longer connected to the top. Return array of bricks dropped after each hit.",
    "constraints": [
      "O(H * Î±(N)) Time",
      "Union Find (Reverse)"
    ],
    "family_tree": {
      "remedial_id": "q_200",
      "tutorial_id": "t_graph_03"
    },
    "starterCode": "def hitBricks(grid: list[list[int]], hits: list[list[int]]) -> list[int]:\n    \"\"\"Return dropped bricks after each hit.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[1,0,0,0],[1,1,1,0]], [[1,0]]",
        "expectedOutput": "[2]"
      },
      {
        "id": "test-2",
        "input": "[[1,0,0,0],[1,1,0,0]], [[1,1],[1,0]]",
        "expectedOutput": "[0, 0]"
      }
    ],
    "hints": [
      "Reverse the process: start with the grid after all hits.",
      "Add bricks back in reverse order of hits.",
      "Use Union-Find to track component connected to top."
    ],
    "solution": "def hitBricks(grid: list[list[int]], hits: list[list[int]]) -> list[int]:\n    m, n = len(grid), len(grid[0])\n    \n    # Mark all hits as 0 (removed) tentatively\n    # If grid had 0 initially, mark as -1 to distinguish\n    for r, c in hits:\n        if grid[r][c] == 1:\n            grid[r][c] = 0\n        else:\n            grid[r][c] = -1 # Was already empty\n            \n    # Union Find setup\n    parent = list(range(m * n + 1))\n    sz = [1] * (m * n + 1)\n    \n    def find(x):\n        if parent[x] != x: parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootx, rooty = find(x), find(y)\n        if rootx != rooty:\n            parent[rootx] = rooty\n            sz[rooty] += sz[rootx]\n            \n    def index(r, c):\n        return r * n + c\n        \n    # Connect initial stable bricks\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                if r == 0: union(index(r, c), m * n) # Connect to roof\n                if r > 0 and grid[r-1][c] == 1: union(index(r, c), index(r-1, c))\n                if c > 0 and grid[r][c-1] == 1: union(index(r, c), index(r, c-1))\n                \n    result = []\n    for r, c in reversed(hits):\n        if grid[r][c] == -1: # Was empty\n            result.append(0)\n            continue\n            \n        grid[r][c] = 1 # Add brick back\n        prev_roof_size = sz[find(m * n)]\n        \n        # Union with neighbors\n        if r == 0: union(index(r, c), m * n)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:\n                union(index(r, c), index(nr, nc))\n                \n        current_roof_size = sz[find(m * n)]\n        dropped = max(0, current_roof_size - prev_roof_size - 1)\n        result.append(dropped)\n        \n    return result[::-1]"
  },
  {
    "id": "q_417",
    "title": "Pacific Atlantic Water Flow",
    "prompt": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the left and top edges of the island, and the Atlantic Ocean touches the right and bottom edges. Rain water flows to neighboring cells if the neighbor is lower or equal height. Return a list of grid coordinates where water can flow to both the Pacific and Atlantic Oceans.",
    "constraints": [
      "O(M*N) Time",
      "DFS/BFS from Oceans"
    ],
    "family_tree": {
      "remedial_id": "q_200",
      "tutorial_id": "t_graph_03"
    },
    "starterCode": "def pacificAtlantic(heights: list[list[int]]) -> list[list[int]]:\n    \"\"\"Return coordinates that can flow to both oceans.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
        "expectedOutput": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
      },
      {
        "id": "test-2",
        "input": "[[2,1],[1,2]]",
        "expectedOutput": "[[0,0],[0,1],[1,0],[1,1]]"
      }
    ],
    "hints": [
      "Run DFS/BFS from Pacific Ocean cells (top/left) to reach reachable cells.",
      "Run DFS/BFS from Atlantic Ocean cells (right/bottom).",
      "Find intersection of cells reachable from both."
    ],
    "solution": "def pacificAtlantic(heights: list[list[int]]) -> list[list[int]]:\n    if not heights: return []\n    m, n = len(heights), len(heights[0])\n    pacific = set()\n    atlantic = set()\n    \n    def dfs(r, c, visit, prev_h):\n        if (r, c) in visit or r < 0 or r >= m or c < 0 or c >= n or heights[r][c] < prev_h:\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])\n        \n    for c in range(n):\n        dfs(0, c, pacific, heights[0][c])\n        dfs(m - 1, c, atlantic, heights[m - 1][c])\n        \n    for r in range(m):\n        dfs(r, 0, pacific, heights[r][0])\n        dfs(r, n - 1, atlantic, heights[r][n - 1])\n        \n    return list(pacific & atlantic)"
  },
  {
    "id": "q_994",
    "title": "Rotting Oranges",
    "prompt": "You are given an m x n grid where each cell has the following values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
    "constraints": [
      "O(M*N) Time",
      "Multi-source BFS"
    ],
    "family_tree": {
      "remedial_id": "q_733",
      "tutorial_id": "t_graph_01"
    },
    "starterCode": "def orangesRotting(grid: list[list[int]]) -> int:\n    \"\"\"Return min minutes to rot all oranges.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[2,1,1],[1,1,0],[0,1,1]]",
        "expectedOutput": "4"
      },
      {
        "id": "test-2",
        "input": "[[2,1,1],[0,1,1],[1,0,1]]",
        "expectedOutput": "-1"
      },
      {
        "id": "test-3",
        "input": "[[0,2]]",
        "expectedOutput": "0"
      }
    ],
    "hints": [
      "Use BFS starting from all rotten oranges (multi-source BFS).",
      "Track time level by level.",
      "Check if fresh oranges remain count is 0 at end."
    ],
    "solution": "from collections import deque\n\ndef orangesRotting(grid: list[list[int]]) -> int:\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    fresh = 0\n    time = 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                queue.append((r, c))\n                \n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    while queue and fresh > 0:\n        for i in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in directions:\n                row, col = r + dr, c + dc\n                if (row < 0 or row == rows or\n                    col < 0 or col == cols or\n                    grid[row][col] != 1):\n                    continue\n                grid[row][col] = 2\n                queue.append((row, col))\n                fresh -= 1\n        time += 1\n        \n    return time if fresh == 0 else -1"
  },
  {
    "id": "q_130",
    "title": "Surrounded Regions",
    "prompt": "Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region.",
    "constraints": [
      "O(M*N) Time",
      "Reverse DFS from Border"
    ],
    "family_tree": {
      "remedial_id": "q_200",
      "tutorial_id": "t_graph_03"
    },
    "starterCode": "def solve(board: list[list[str]]) -> None:\n    \"\"\"Capture surrounded regions in-place.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
        "expectedOutput": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
      },
      {
        "id": "test-2",
        "input": "[[\"X\"]]",
        "expectedOutput": "[[\"X\"]]"
      }
    ],
    "hints": [
      "'O's on the border cannot be captured.",
      "DFS from all border 'O's and mark them as safe.",
      "Flip all remaining 'O's to 'X', and revert safe 'O's back."
    ],
    "solution": "def solve(board: list[list[str]]) -> None:\n    rows, cols = len(board), len(board[0])\n    \n    def capture(r, c):\n        if r < 0 or c < 0 or r == rows or c == cols or board[r][c] != \"O\":\n            return\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n        \n    for r in range(rows):\n        for c in range(cols):\n            if (board[r][c] == \"O\" and\n                (r in [0, rows - 1] or c in [0, cols - 1])):\n                capture(r, c)\n                \n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\""
  },
  {
    "id": "q_117",
    "title": "Populating Next Right Pointers in Each Node II",
    "prompt": "Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. The tree structure is not perfect binary tree.",
    "constraints": [
      "O(N) Time",
      "O(1) Space (Ideal) or O(N)"
    ],
    "family_tree": {
      "remedial_id": "q_104",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "def connect(root: 'Node') -> 'Node':\n    \"\"\"Populate next right pointers.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1,2,3,4,5,null,7]",
        "expectedOutput": "[1,#,2,3,#,4,5,7,#]"
      }
    ],
    "hints": [
      "Use a dummy node to track the start of the next level.",
      "Iterate through the current level as a linked list."
    ],
    "solution": "def connect(root: 'Node') -> 'Node':\n    if not root: return None\n    curr = root\n    while curr:\n        dummy = Node(0)\n        tail = dummy\n        while curr:\n            if curr.left:\n                tail.next = curr.left\n                tail = tail.next\n            if curr.right:\n                tail.next = curr.right\n                tail = tail.next\n            curr = curr.next\n        curr = dummy.next\n    return root"
  },
  {
    "id": "q_437",
    "title": "Path Sum III",
    "prompt": "Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards.",
    "constraints": [
      "O(N) Time (Prefix Sum)",
      "O(N^2) (Brute Force)"
    ],
    "family_tree": {
      "remedial_id": "q_112",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "def pathSum(root: TreeNode, targetSum: int) -> int:\n    \"\"\"Return number of valid paths.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[10,5,-3,3,2,null,11,3,-2,null,1], 8",
        "expectedOutput": "3"
      },
      {
        "id": "test-2",
        "input": "[5,4,8,11,null,13,4,7,2,null,null,5,1], 22",
        "expectedOutput": "3"
      }
    ],
    "hints": [
      "Use Prefix Sum technique with DFS.",
      "Keep a running sum and a map of {sum: count}."
    ],
    "solution": "def pathSum(root: TreeNode, targetSum: int) -> int:\n    count = 0\n    cache = {0: 1}\n    \n    def dfs(node, curr_sum):\n        nonlocal count\n        if not node:\n            return\n        curr_sum += node.val\n        count += cache.get(curr_sum - targetSum, 0)\n        cache[curr_sum] = cache.get(curr_sum, 0) + 1\n        dfs(node.left, curr_sum)\n        dfs(node.right, curr_sum)\n        cache[curr_sum] -= 1\n        \n    dfs(root, 0)\n    return count"
  },
  {
    "id": "q_113",
    "title": "Path Sum II",
    "prompt": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum.",
    "constraints": [
      "O(N) Time",
      "DFS / Backtracking"
    ],
    "family_tree": {
      "remedial_id": "q_112",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "def pathSum(root: TreeNode, targetSum: int) -> list[list[int]]:\n    \"\"\"Return all root-to-leaf paths with target sum.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[5,4,8,11,null,13,4,7,2,null,null,5,1], 22",
        "expectedOutput": "[[5,4,11,2],[5,8,4,5]]"
      },
      {
        "id": "test-2",
        "input": "[1,2,3], 5",
        "expectedOutput": "[]"
      }
    ],
    "hints": [
      "DFS keeping track of the current path.",
      "Add path to result when leaf is reached and sum matches."
    ],
    "solution": "def pathSum(root: TreeNode, targetSum: int) -> list[list[int]]:\n    res = []\n    def dfs(node, current_path, current_sum):\n        if not node:\n            return\n        current_path.append(node.val)\n        current_sum += node.val\n        if not node.left and not node.right and current_sum == targetSum:\n            res.append(list(current_path))\n        else:\n            dfs(node.left, current_path, current_sum)\n            dfs(node.right, current_path, current_sum)\n        current_path.pop()\n    \n    dfs(root, [], 0)\n    return res"
  },
  {
    "id": "q_222",
    "title": "Count Complete Tree Nodes",
    "prompt": "Given the root of a complete binary tree, return the number of the nodes. Design an algorithm that runs in less than O(n) time complexity.",
    "constraints": [
      "O(log^2 N) Time",
      "Binary Search on Tree"
    ],
    "family_tree": {
      "remedial_id": "q_104",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "def countNodes(root: TreeNode) -> int:\n    \"\"\"Return number of nodes in complete tree.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1,2,3,4,5,6]",
        "expectedOutput": "6"
      },
      {
        "id": "test-2",
        "input": "[]",
        "expectedOutput": "0"
      },
      {
        "id": "test-3",
        "input": "[1]",
        "expectedOutput": "1"
      }
    ],
    "hints": [
      "Compare height of left and right subtrees.",
      "If height(root.right) == h-1, left subtree is full.",
      "Otherwise, right subtree is full."
    ],
    "solution": "def countNodes(root: TreeNode) -> int:\n    if not root: return 0\n    \n    def get_height(node):\n        h = 0\n        while node:\n            h += 1\n            node = node.left\n        return h\n    \n    h = get_height(root)\n    if get_height(root.right) == h - 1:\n        return (1 << (h - 1)) + countNodes(root.right)\n    else:\n        return (1 << (h - 2)) + countNodes(root.left)"
  },
  {
    "id": "q_951",
    "title": "Flip Equivalent Binary Trees",
    "prompt": "For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. Two trees X and Y are flip equivalent if they can be made equal after some number of flip operations. Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.",
    "constraints": [
      "O(N) Time",
      "Recursive Tree Matching"
    ],
    "family_tree": {
      "remedial_id": "q_100",
      "tutorial_id": "t_tree_02"
    },
    "starterCode": "def flipEquiv(root1: TreeNode, root2: TreeNode) -> bool:\n    \"\"\"Return True if trees are flip equivalent.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1,2,3,4,5,6,null,null,null,7,8], [1,3,2,null,6,4,5,null,null,null,null,8,7]",
        "expectedOutput": "true"
      },
      {
        "id": "test-2",
        "input": "[], []",
        "expectedOutput": "true"
      },
      {
        "id": "test-3",
        "input": "[], [1]",
        "expectedOutput": "false"
      }
    ],
    "hints": [
      "If roots are null, they are equivalent.",
      "If one is null or values differ, not equivalent.",
      "Check if regular match OR flipped match."
    ],
    "solution": "def flipEquiv(root1: TreeNode, root2: TreeNode) -> bool:\n    if not root1 or not root2:\n        return not root1 and not root2\n    if root1.val != root2.val:\n        return False\n        \n    return (flipEquiv(root1.left, root2.left) and flipEquiv(root1.right, root2.right)) or \\\n           (flipEquiv(root1.left, root2.right) and flipEquiv(root1.right, root2.left))"
  },
  {
    "id": "q_490",
    "title": "The Maze",
    "prompt": "There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. Given the ball's start position, the destination and the maze, determine whether the ball can stop at the destination.",
    "constraints": [
      "O(M*N) Time",
      "BFS/DFS"
    ],
    "family_tree": {
      "remedial_id": "q_200",
      "tutorial_id": "t_graph_01"
    },
    "starterCode": "def hasPath(maze: list[list[int]], start: list[int], destination: list[int]) -> bool:\n    \"\"\"Return True if path exists.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], [0,4], [4,4]",
        "expectedOutput": "true"
      },
      {
        "id": "test-2",
        "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], [0,4], [3,2]",
        "expectedOutput": "false"
      }
    ],
    "hints": [
      "Ball rolls until it hits a wall. This defines the edges in our graph.",
      "Use BFS to explore reachable stopping points."
    ],
    "solution": "from collections import deque\ndef hasPath(maze: list[list[int]], start: list[int], destination: list[int]) -> bool:\n    m, n = len(maze), len(maze[0])\n    queue = deque([tuple(start)])\n    visited = {tuple(start)}\n    \n    while queue:\n        r, c = queue.popleft()\n        if [r, c] == destination:\n            return True\n            \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r, c\n            # Roll until wall\n            while 0 <= nr + dr < m and 0 <= nc + dc < n and maze[nr + dr][nc + dc] == 0:\n                nr += dr\n                nc += dc\n            \n            if (nr, nc) not in visited:\n                visited.add((nr, nc))\n                queue.append((nr, nc))\n    return False"
  },
  {
    "id": "q_505",
    "title": "The Maze II",
    "prompt": "There is a ball in a maze with empty spaces (0) and walls (1). The ball rolls until it hits a wall. Determine the shortest distance for the ball to stop at the destination. If the ball cannot stop at the destination, return -1. The distance is the number of empty spaces traveled.",
    "constraints": [
      "O(M*N log(MN)) Time",
      "Dijkstra"
    ],
    "family_tree": {
      "remedial_id": "q_490",
      "tutorial_id": "t_graph_02"
    },
    "starterCode": "def shortestDistance(maze: list[list[int]], start: list[int], destination: list[int]) -> int:\n    \"\"\"Return shortest distance or -1.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], [0,4], [4,4]",
        "expectedOutput": "12"
      },
      {
        "id": "test-2",
        "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], [0,4], [3,2]",
        "expectedOutput": "-1"
      }
    ],
    "hints": [
      "Use Dijkstra's algorithm.",
      "State is (row, col). Edge weight is distance rolled."
    ],
    "solution": "import heapq\ndef shortestDistance(maze: list[list[int]], start: list[int], destination: list[int]) -> int:\n    m, n = len(maze), len(maze[0])\n    pq = [(0, start[0], start[1])]\n    dists = {(start[0], start[1]): 0}\n    \n    while pq:\n        d, r, c = heapq.heappop(pq)\n        if d > dists.get((r, c), float('inf')):\n            continue\n        if [r, c] == destination:\n            return d\n            \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r, c\n            steps = 0\n            while 0 <= nr + dr < m and 0 <= nc + dc < n and maze[nr + dr][nc + dc] == 0:\n                nr += dr\n                nc += dc\n                steps += 1\n            \n            new_dist = d + steps\n            if new_dist < dists.get((nr, nc), float('inf')):\n                dists[(nr, nc)] = new_dist\n                heapq.heappush(pq, (new_dist, nr, nc))\n                \n    return -1"
  },
  {
    "id": "q_399",
    "title": "Evaluate Division",
    "prompt": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. You are also given some queries. Return the answers to all queries.",
    "constraints": [
      "O(N) Time",
      "Graph DFS/BFS"
    ],
    "family_tree": {
      "remedial_id": "q_200",
      "tutorial_id": "t_graph_02"
    },
    "starterCode": "def calcEquation(equations: list[list[str]], values: list[float], queries: list[list[str]]) -> list[float]:\n    \"\"\"Return answers for queries.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0,3.0], [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"]]",
        "expectedOutput": "[6.00000, 0.50000, -1.00000]"
      }
    ],
    "hints": [
      "Treat variables as nodes and equations as directed edges with weights.",
      "a/b = 2.0 means edge a->b weight 2.0, b->a weight 0.5.",
      "Find path product from start to end."
    ],
    "solution": "from collections import defaultdict, deque\ndef calcEquation(equations: list[list[str]], values: list[float], queries: list[list[str]]) -> list[float]:\n    graph = defaultdict(dict)\n    for (u, v), val in zip(equations, values):\n        graph[u][v] = val\n        graph[v][u] = 1.0 / val\n        \n    def bfs(src, dst):\n        if src not in graph or dst not in graph:\n            return -1.0\n        queue = deque([(src, 1.0)])\n        visited = {src}\n        while queue:\n            curr, prod = queue.popleft()\n            if curr == dst:\n                return prod\n            for neighbor, weight in graph[curr].items():\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, prod * weight))\n        return -1.0\n        \n    return [bfs(q[0], q[1]) for q in queries]"
  },
  {
    "id": "q_317",
    "title": "Shortest Distance from All Buildings",
    "prompt": "You are given an m x n grid grid of values 0 (empty), 1 (building), 2 (obstacle). You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, right.",
    "constraints": [
      "O(K * M*N) Time",
      "BFS from Buildings"
    ],
    "family_tree": {
      "remedial_id": "q_200",
      "tutorial_id": "t_graph_02"
    },
    "starterCode": "def shortestDistance(grid: list[list[int]]) -> int:\n    \"\"\"Return min total distance.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]",
        "expectedOutput": "7"
      },
      {
        "id": "test-2",
        "input": "[[1,0]]",
        "expectedOutput": "1"
      },
      {
        "id": "test-3",
        "input": "[[1]]",
        "expectedOutput": "-1"
      }
    ],
    "hints": [
      "Run BFS from EACH building to find distances to all empty cells.",
      "Sum distances at each empty cell.",
      "Track how many buildings reached each empty cell (must reach all)."
    ],
    "solution": "from collections import deque\ndef shortestDistance(grid: list[list[int]]) -> int:\n    if not grid: return -1\n    m, n = len(grid), len(grid[0])\n    total_dist = [[0] * n for _ in range(m)]\n    reach_count = [[0] * n for _ in range(m)]\n    buildings = 0\n    \n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                buildings += 1\n                queue = deque([(r, c, 0)])\n                visited = [[False] * n for _ in range(m)]\n                visited[r][c] = True\n                \n                while queue:\n                    curr_r, curr_c, dist = queue.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] == 0:\n                            visited[nr][nc] = True\n                            total_dist[nr][nc] += dist + 1\n                            reach_count[nr][nc] += 1\n                            queue.append((nr, nc, dist + 1))\n                            \n    min_dist = float('inf')\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and reach_count[r][c] == buildings:\n                min_dist = min(min_dist, total_dist[r][c])\n                \n    return min_dist if min_dist != float('inf') else -1"
  },
  {
    "id": "q_737",
    "title": "Sentence Similarity II",
    "prompt": "We can represent a sentence as an array of words. Given two sentences sentence1 and sentence2 each represented as a string array and given an array of string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that the two words xi and yi are similar. Return true if sentence1 and sentence2 are similar. Similarity is transitive.",
    "constraints": [
      "O(N + P) Time",
      "Union-Find"
    ],
    "family_tree": {
      "remedial_id": "q_323",
      "tutorial_id": "t_graph_03"
    },
    "starterCode": "def areSentencesSimilarTwo(sentence1: list[str], sentence2: list[str], similarPairs: list[list[str]]) -> bool:\n    \"\"\"Return True if sentences are similar.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[\"great\",\"acting\",\"skills\"], [\"fine\",\"drama\",\"talent\"], [[\"great\",\"fine\"],[\"drama\",\"acting\"],[\"skills\",\"talent\"]]",
        "expectedOutput": "true"
      }
    ],
    "hints": [
      "Use Union-Find to group similar words.",
      "Check if words at same index belong to same group."
    ],
    "solution": "def areSentencesSimilarTwo(sentence1: list[str], sentence2: list[str], similarPairs: list[list[str]]) -> bool:\n    if len(sentence1) != len(sentence2):\n        return False\n        \n    parent = {}\n    def find(x):\n        if x not in parent:\n            parent[x] = x\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n        \n    for a, b in similarPairs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            parent[pa] = pb\n            \n    for w1, w2 in zip(sentence1, sentence2):\n        if w1 != w2 and find(w1) != find(w2):\n            return False\n            \n    return True"
  },
  {
    "id": "q_547",
    "title": "Number of Provinces (Friend Circles)",
    "prompt": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces.",
    "constraints": [
      "O(N^2) Time",
      "DFS / Union-Find"
    ],
    "family_tree": {
      "remedial_id": "q_323",
      "tutorial_id": "t_graph_03"
    },
    "starterCode": "def findCircleNum(isConnected: list[list[int]]) -> int:\n    \"\"\"Return number of provinces.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[1,1,0],[1,1,0],[0,0,1]]",
        "expectedOutput": "2"
      },
      {
        "id": "test-2",
        "input": "[[1,0,0],[0,1,0],[0,0,1]]",
        "expectedOutput": "3"
      }
    ],
    "hints": [
      "Similar to counting islands or connected components.",
      "Use DFS or BFS to visit all nodes in a component."
    ],
    "solution": "def findCircleNum(isConnected: list[list[int]]) -> int:\n    n = len(isConnected)\n    visited = [False] * n\n    count = 0\n    \n    def dfs(node):\n        for nei, connected in enumerate(isConnected[node]):\n            if connected and not visited[nei]:\n                visited[nei] = True\n                dfs(nei)\n                \n    for i in range(n):\n        if not visited[i]:\n            visited[i] = True\n            count += 1\n            dfs(i)\n            \n    return count"
  }
]