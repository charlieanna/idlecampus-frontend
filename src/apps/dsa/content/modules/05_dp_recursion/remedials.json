[
  {
    "id": "q_70",
    "title": "Climbing Stairs",
    "prompt": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "concept_taught": "Basic Fibonacci DP",
    "starterCode": "def climbStairs(n: int) -> int:\n    \"\"\"Return number of distinct ways to climb n stairs.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "2", "expectedOutput": "2"},
      {"id": "test-2", "input": "3", "expectedOutput": "3"},
      {"id": "test-3", "input": "5", "expectedOutput": "8"}
    ],
    "hints": [
      "To reach step n, you can come from n-1 or n-2.",
      "ways(n) = ways(n-1) + ways(n-2) - just like Fibonacci!",
      "Base cases: ways(1)=1, ways(2)=2."
    ],
    "solution": "def climbStairs(n: int) -> int:\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n    for _ in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    \n    return prev1"
  },
  {
    "id": "q_198",
    "title": "House Robber",
    "prompt": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. Adjacent houses have security systems connected - if you rob two adjacent houses, the police will be alerted. Given an array representing the amount at each house, return the maximum amount you can rob without alerting the police.",
    "concept_taught": "Skip-1 Dependency",
    "starterCode": "def rob(nums: list[int]) -> int:\n    \"\"\"Return maximum amount that can be robbed.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 2, 3, 1]", "expectedOutput": "4"},
      {"id": "test-2", "input": "[2, 7, 9, 3, 1]", "expectedOutput": "12"},
      {"id": "test-3", "input": "[2, 1, 1, 2]", "expectedOutput": "4"}
    ],
    "hints": [
      "At each house, choose: rob it + best from 2 houses back, or skip it.",
      "dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
      "Only need last two values, not full array."
    ],
    "solution": "def rob(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev2, prev1 = 0, 0\n    for num in nums:\n        curr = max(prev1, prev2 + num)\n        prev2, prev1 = prev1, curr\n    \n    return prev1"
  },
  {
    "id": "q_746",
    "title": "Min Cost Climbing Stairs",
    "prompt": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can start from index 0 or index 1. Return the minimum cost to reach the top of the floor.",
    "concept_taught": "Min Path to Current",
    "starterCode": "def minCostClimbingStairs(cost: list[int]) -> int:\n    \"\"\"Return minimum cost to reach the top.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[10, 15, 20]", "expectedOutput": "15"},
      {"id": "test-2", "input": "[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]", "expectedOutput": "6"},
      {"id": "test-3", "input": "[0, 0, 0, 1]", "expectedOutput": "0"}
    ],
    "hints": [
      "To reach step i, come from i-1 or i-2 (whichever is cheaper).",
      "dp[i] = cost[i] + min(dp[i-1], dp[i-2])",
      "Top is one step past the last stair."
    ],
    "solution": "def minCostClimbingStairs(cost: list[int]) -> int:\n    n = len(cost)\n    prev2, prev1 = cost[0], cost[1]\n    \n    for i in range(2, n):\n        curr = cost[i] + min(prev1, prev2)\n        prev2, prev1 = prev1, curr\n    \n    return min(prev1, prev2)"
  },
  {
    "id": "q_509",
    "title": "Fibonacci Number",
    "prompt": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. Given n, calculate F(n).",
    "concept_taught": "Recursion vs Iteration",
    "starterCode": "def fib(n: int) -> int:\n    \"\"\"Return the nth Fibonacci number.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "2", "expectedOutput": "1"},
      {"id": "test-2", "input": "3", "expectedOutput": "2"},
      {"id": "test-3", "input": "10", "expectedOutput": "55"}
    ],
    "hints": [
      "F(n) = F(n-1) + F(n-2)",
      "Base cases: F(0)=0, F(1)=1",
      "Iterative solution avoids repeated computation."
    ],
    "solution": "def fib(n: int) -> int:\n    if n <= 1:\n        return n\n    \n    prev2, prev1 = 0, 1\n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    \n    return prev1"
  },
  {
    "id": "q_118",
    "title": "Pascal's Triangle",
    "prompt": "Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it.",
    "concept_taught": "Previous Row Dependency",
    "starterCode": "def generate(numRows: int) -> list[list[int]]:\n    \"\"\"Return first numRows of Pascal's triangle.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "5", "expectedOutput": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"},
      {"id": "test-2", "input": "1", "expectedOutput": "[[1]]"},
      {"id": "test-3", "input": "3", "expectedOutput": "[[1],[1,1],[1,2,1]]"}
    ],
    "hints": [
      "Each row starts and ends with 1.",
      "Middle elements: row[j] = prev_row[j-1] + prev_row[j]",
      "Build row by row, using previous row."
    ],
    "solution": "def generate(numRows: int) -> list[list[int]]:\n    triangle = [[1]]\n    \n    for i in range(1, numRows):\n        prev = triangle[-1]\n        row = [1]\n        for j in range(1, i):\n            row.append(prev[j-1] + prev[j])\n        row.append(1)\n        triangle.append(row)\n    \n    return triangle"
  },
  {
    "id": "q_1137",
    "title": "N-th Tribonacci Number",
    "prompt": "The Tribonacci sequence Tn is defined as: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given n, return the value of Tn.",
    "concept_taught": "State of 3 Variables",
    "starterCode": "def tribonacci(n: int) -> int:\n    \"\"\"Return the nth Tribonacci number.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "4", "expectedOutput": "4"},
      {"id": "test-2", "input": "25", "expectedOutput": "1389537"},
      {"id": "test-3", "input": "0", "expectedOutput": "0"}
    ],
    "hints": [
      "Like Fibonacci but with 3 terms.",
      "T(n) = T(n-1) + T(n-2) + T(n-3)",
      "Track 3 variables instead of 2."
    ],
    "solution": "def tribonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    if n <= 2:\n        return 1\n    \n    t0, t1, t2 = 0, 1, 1\n    for _ in range(3, n + 1):\n        t0, t1, t2 = t1, t2, t0 + t1 + t2\n    \n    return t2"
  },
  {
    "id": "q_338",
    "title": "Counting Bits",
    "prompt": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
    "concept_taught": "DP on Bits",
    "starterCode": "def countBits(n: int) -> list[int]:\n    \"\"\"Return array where ans[i] = number of 1s in binary of i.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "2", "expectedOutput": "[0, 1, 1]"},
      {"id": "test-2", "input": "5", "expectedOutput": "[0, 1, 1, 2, 1, 2]"},
      {"id": "test-3", "input": "0", "expectedOutput": "[0]"}
    ],
    "hints": [
      "i & (i-1) removes the lowest set bit.",
      "ans[i] = ans[i & (i-1)] + 1",
      "Or: ans[i] = ans[i >> 1] + (i & 1)"
    ],
    "solution": "def countBits(n: int) -> list[int]:\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i >> 1] + (i & 1)\n    return ans"
  },
  {
    "id": "q_53",
    "title": "Maximum Subarray",
    "prompt": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "concept_taught": "Kadane's Algorithm",
    "starterCode": "def maxSubArray(nums: list[int]) -> int:\n    \"\"\"Return the maximum subarray sum.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]", "expectedOutput": "6"},
      {"id": "test-2", "input": "[1]", "expectedOutput": "1"},
      {"id": "test-3", "input": "[5, 4, -1, 7, 8]", "expectedOutput": "23"}
    ],
    "hints": [
      "At each position: extend current subarray or start new.",
      "curr_sum = max(nums[i], curr_sum + nums[i])",
      "Track maximum sum seen."
    ],
    "solution": "def maxSubArray(nums: list[int]) -> int:\n    curr_sum = max_sum = nums[0]\n    \n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum"
  },
  {
    "id": "q_5",
    "title": "Longest Palindromic Substring",
    "prompt": "Given a string s, return the longest palindromic substring in s.",
    "concept_taught": "Expand Around Center (Simple)",
    "starterCode": "def longestPalindrome(s: str) -> str:\n    \"\"\"Return the longest palindromic substring.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "\"babad\"", "expectedOutput": "\"bab\""},
      {"id": "test-2", "input": "\"cbbd\"", "expectedOutput": "\"bb\""},
      {"id": "test-3", "input": "\"a\"", "expectedOutput": "\"a\""}
    ],
    "hints": [
      "Try each position as center of palindrome.",
      "Expand outward while characters match.",
      "Handle both odd and even length palindromes."
    ],
    "solution": "def longestPalindrome(s: str) -> str:\n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return s[l+1:r]\n    \n    result = \"\"\n    for i in range(len(s)):\n        # Odd length\n        odd = expand(i, i)\n        if len(odd) > len(result):\n            result = odd\n        # Even length\n        even = expand(i, i + 1)\n        if len(even) > len(result):\n            result = even\n    \n    return result"
  },
  {
    "id": "q_416",
    "title": "Partition Equal Subset Sum",
    "prompt": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal.",
    "concept_taught": "Intro to Knapsack",
    "starterCode": "def canPartition(nums: list[int]) -> bool:\n    \"\"\"Return True if array can be partitioned into equal sum subsets.\"\"\"\n    pass",
    "testCases": [
      {"id": "test-1", "input": "[1, 5, 11, 5]", "expectedOutput": "true"},
      {"id": "test-2", "input": "[1, 2, 3, 5]", "expectedOutput": "false"},
      {"id": "test-3", "input": "[1, 2, 5]", "expectedOutput": "false"}
    ],
    "hints": [
      "If total sum is odd, impossible.",
      "Find if subset with sum = total/2 exists.",
      "Use dp[i] = can we form sum i?"
    ],
    "solution": "def canPartition(nums: list[int]) -> bool:\n    total = sum(nums)\n    if total % 2 != 0:\n        return False\n    \n    target = total // 2\n    dp = {0}\n    \n    for num in nums:\n        dp = dp | {x + num for x in dp if x + num <= target}\n        if target in dp:\n            return True\n    \n    return target in dp"
  }
]
