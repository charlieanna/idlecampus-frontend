[
  {
    "id": "q_72",
    "title": "Edit Distance",
    "prompt": "Given two strings word1 and word2, return the minimum number of operations (insert, delete, replace) to convert word1 to word2.",
    "constraints": [
      "O(M*N) Time",
      "2D DP"
    ],
    "family_tree": {
      "remedial_id": "q_1143",
      "tutorial_id": "t_dp_02"
    },
    "starterCode": "def minDistance(word1: str, word2: str) -> int:\n    \"\"\"Return minimum edit distance.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "\"horse\", \"ros\"",
        "expectedOutput": "3"
      },
      {
        "id": "test-2",
        "input": "\"intention\", \"execution\"",
        "expectedOutput": "5"
      },
      {
        "id": "test-3",
        "input": "\"\", \"a\"",
        "expectedOutput": "1"
      }
    ],
    "hints": [
      "dp[i][j] = min ops to convert word1[:i] to word2[:j].",
      "If chars match: dp[i][j] = dp[i-1][j-1].",
      "Else: 1 + min(insert, delete, replace)."
    ],
    "solution": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]"
  },
  {
    "id": "q_312",
    "title": "Burst Balloons",
    "prompt": "Given n balloons with numbers, burst all to maximize coins. When you burst balloon i, you get nums[i-1] * nums[i] * nums[i+1] coins.",
    "constraints": [
      "O(N^3) Time",
      "Interval DP"
    ],
    "family_tree": {
      "remedial_id": "q_198",
      "tutorial_id": "t_dp_03"
    },
    "starterCode": "def maxCoins(nums: list[int]) -> int:\n    \"\"\"Return maximum coins from bursting all balloons.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[3, 1, 5, 8]",
        "expectedOutput": "167"
      },
      {
        "id": "test-2",
        "input": "[1, 5]",
        "expectedOutput": "10"
      },
      {
        "id": "test-3",
        "input": "[1]",
        "expectedOutput": "1"
      }
    ],
    "hints": [
      "Think backwards: which balloon to burst LAST in range.",
      "dp[i][j] = max coins from bursting all balloons in (i,j) range.",
      "Add boundary 1s to handle edge cases."
    ],
    "solution": "def maxCoins(nums: list[int]) -> int:\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n):\n        for left in range(n - length):\n            right = left + length\n            for k in range(left + 1, right):\n                dp[left][right] = max(dp[left][right],\n                    nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right])\n    \n    return dp[0][n-1]"
  },
  {
    "id": "q_322",
    "title": "Coin Change",
    "prompt": "Given coins of different denominations and an amount, return fewest coins needed to make up that amount. Return -1 if impossible.",
    "constraints": [
      "O(A*N) Time",
      "Unbounded Knapsack"
    ],
    "family_tree": {
      "remedial_id": "q_70",
      "tutorial_id": "t_dp_01"
    },
    "starterCode": "def coinChange(coins: list[int], amount: int) -> int:\n    \"\"\"Return fewest coins to make amount.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 2, 5], 11",
        "expectedOutput": "3"
      },
      {
        "id": "test-2",
        "input": "[2], 3",
        "expectedOutput": "-1"
      },
      {
        "id": "test-3",
        "input": "[1], 0",
        "expectedOutput": "0"
      }
    ],
    "hints": [
      "dp[i] = fewest coins to make amount i.",
      "For each amount, try all coins.",
      "dp[i] = min(dp[i], dp[i-coin] + 1)."
    ],
    "solution": "def coinChange(coins: list[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i and dp[i - coin] != float('inf'):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1"
  },
  {
    "id": "q_300",
    "title": "Longest Increasing Subsequence",
    "prompt": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "constraints": [
      "O(N log N) Time",
      "Patience Sorting / DP"
    ],
    "family_tree": {
      "remedial_id": "q_674",
      "tutorial_id": "t_dp_01"
    },
    "starterCode": "def lengthOfLIS(nums: list[int]) -> int:\n    \"\"\"Return length of longest increasing subsequence.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[10, 9, 2, 5, 3, 7, 101, 18]",
        "expectedOutput": "4"
      },
      {
        "id": "test-2",
        "input": "[0, 1, 0, 3, 2, 3]",
        "expectedOutput": "4"
      },
      {
        "id": "test-3",
        "input": "[7, 7, 7, 7]",
        "expectedOutput": "1"
      }
    ],
    "hints": [
      "O(N^2): dp[i] = LIS ending at i.",
      "O(N log N): maintain sorted list, binary search insertion point.",
      "tails[i] = smallest tail of LIS with length i+1."
    ],
    "solution": "def lengthOfLIS(nums: list[int]) -> int:\n    import bisect\n    \n    tails = []\n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)"
  },
  {
    "id": "q_139",
    "title": "Word Break",
    "prompt": "Given string s and dictionary wordDict, return true if s can be segmented into space-separated dictionary words.",
    "constraints": [
      "O(N^2) Time",
      "1D DP + Set"
    ],
    "family_tree": {
      "remedial_id": "q_70",
      "tutorial_id": "t_dp_01"
    },
    "starterCode": "def wordBreak(s: str, wordDict: list[str]) -> bool:\n    \"\"\"Return True if s can be segmented.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "\"leetcode\", [\"leet\", \"code\"]",
        "expectedOutput": "true"
      },
      {
        "id": "test-2",
        "input": "\"applepenapple\", [\"apple\", \"pen\"]",
        "expectedOutput": "true"
      },
      {
        "id": "test-3",
        "input": "\"catsandog\", [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]",
        "expectedOutput": "false"
      }
    ],
    "hints": [
      "dp[i] = can segment s[:i].",
      "Check all possible last words.",
      "dp[i] = dp[j] and s[j:i] in wordDict."
    ],
    "solution": "def wordBreak(s: str, wordDict: list[str]) -> bool:\n    word_set = set(wordDict)\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]"
  },
  {
    "id": "q_152",
    "title": "Maximum Product Subarray",
    "prompt": "Find the contiguous subarray within an array that has the largest product.",
    "constraints": [
      "O(N) Time",
      "Tracking Min & Max"
    ],
    "family_tree": {
      "remedial_id": "q_53",
      "tutorial_id": "t_dp_01"
    },
    "starterCode": "def maxProduct(nums: list[int]) -> int:\n    \"\"\"Return maximum product subarray.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[2, 3, -2, 4]",
        "expectedOutput": "6"
      },
      {
        "id": "test-2",
        "input": "[-2, 0, -1]",
        "expectedOutput": "0"
      },
      {
        "id": "test-3",
        "input": "[-2, 3, -4]",
        "expectedOutput": "24"
      }
    ],
    "hints": [
      "Track both max and min at each position (negative * negative = positive).",
      "Reset when encountering 0.",
      "Result = max of all max values."
    ],
    "solution": "def maxProduct(nums: list[int]) -> int:\n    result = max_prod = min_prod = nums[0]\n    \n    for num in nums[1:]:\n        if num < 0:\n            max_prod, min_prod = min_prod, max_prod\n        \n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        \n        result = max(result, max_prod)\n    \n    return result"
  },
  {
    "id": "q_1143",
    "title": "Longest Common Subsequence",
    "prompt": "Given two strings, return the length of their longest common subsequence.",
    "constraints": [
      "O(M*N) Time",
      "2D DP"
    ],
    "family_tree": {
      "remedial_id": "q_516",
      "tutorial_id": "t_dp_02"
    },
    "starterCode": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    \"\"\"Return length of LCS.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "\"abcde\", \"ace\"",
        "expectedOutput": "3"
      },
      {
        "id": "test-2",
        "input": "\"abc\", \"abc\"",
        "expectedOutput": "3"
      },
      {
        "id": "test-3",
        "input": "\"abc\", \"def\"",
        "expectedOutput": "0"
      }
    ],
    "hints": [
      "dp[i][j] = LCS of text1[:i] and text2[:j].",
      "If chars match: dp[i][j] = dp[i-1][j-1] + 1.",
      "Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])."
    ],
    "solution": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]"
  },
  {
    "id": "q_647",
    "title": "Palindromic Substrings",
    "prompt": "Given a string s, return the number of palindromic substrings in it.",
    "constraints": [
      "O(N^2) Time",
      "Expand from Center"
    ],
    "family_tree": {
      "remedial_id": "q_5",
      "tutorial_id": "t_dp_03"
    },
    "starterCode": "def countSubstrings(s: str) -> int:\n    \"\"\"Return count of palindromic substrings.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "\"abc\"",
        "expectedOutput": "3"
      },
      {
        "id": "test-2",
        "input": "\"aaa\"",
        "expectedOutput": "6"
      },
      {
        "id": "test-3",
        "input": "\"a\"",
        "expectedOutput": "1"
      }
    ],
    "hints": [
      "Expand from each center (2n-1 centers for odd and even length).",
      "Count palindromes while expanding.",
      "Each single char is a palindrome."
    ],
    "solution": "def countSubstrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    def expand(left, right):\n        nonlocal count\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    \n    for i in range(n):\n        expand(i, i)      # Odd length\n        expand(i, i + 1)  # Even length\n    \n    return count"
  },
  {
    "id": "q_97",
    "title": "Interleaving String",
    "prompt": "Given strings s1, s2, s3, find if s3 is formed by interleaving s1 and s2.",
    "constraints": [
      "O(M*N) Time",
      "2D DP"
    ],
    "family_tree": {
      "remedial_id": "q_1143",
      "tutorial_id": "t_dp_02"
    },
    "starterCode": "def isInterleave(s1: str, s2: str, s3: str) -> bool:\n    \"\"\"Return True if s3 is interleaving of s1 and s2.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "\"aabcc\", \"dbbca\", \"aadbbcbcac\"",
        "expectedOutput": "true"
      },
      {
        "id": "test-2",
        "input": "\"aabcc\", \"dbbca\", \"aadbbbaccc\"",
        "expectedOutput": "false"
      },
      {
        "id": "test-3",
        "input": "\"\", \"\", \"\"",
        "expectedOutput": "true"
      }
    ],
    "hints": [
      "dp[i][j] = can s1[:i] and s2[:j] form s3[:i+j].",
      "Check if current s3 char matches s1 or s2.",
      "Base case: dp[0][0] = True."
    ],
    "solution": "def isInterleave(s1: str, s2: str, s3: str) -> bool:\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n    \n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, m + 1):\n        dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or \\\n                       (dp[i][j-1] and s2[j-1] == s3[i+j-1])\n    \n    return dp[m][n]"
  },
  {
    "id": "q_494",
    "title": "Target Sum",
    "prompt": "Given array nums and target, find number of ways to assign + and - signs to make the sum equal to target.",
    "constraints": [
      "O(T*N) Time",
      "0/1 Knapsack Variant"
    ],
    "family_tree": {
      "remedial_id": "q_416",
      "tutorial_id": "t_dp_04"
    },
    "starterCode": "def findTargetSumWays(nums: list[int], target: int) -> int:\n    \"\"\"Return number of ways to reach target.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[1, 1, 1, 1, 1], 3",
        "expectedOutput": "5"
      },
      {
        "id": "test-2",
        "input": "[1], 1",
        "expectedOutput": "1"
      },
      {
        "id": "test-3",
        "input": "[1, 0], 1",
        "expectedOutput": "2"
      }
    ],
    "hints": [
      "Sum of positives - sum of negatives = target.",
      "Sum of positives = (total + target) / 2.",
      "Reduce to subset sum problem."
    ],
    "solution": "def findTargetSumWays(nums: list[int], target: int) -> int:\n    total = sum(nums)\n    if (total + target) % 2 != 0 or abs(target) > total:\n        return 0\n    \n    subset_sum = (total + target) // 2\n    dp = [0] * (subset_sum + 1)\n    dp[0] = 1\n    \n    for num in nums:\n        for j in range(subset_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    \n    return dp[subset_sum]"
  },
  {
    "id": "q_1055",
    "title": "Shortest Way to Form String",
    "prompt": "From any string, we can form a subsequence of that string. Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If impossible, return -1.",
    "constraints": [
      "O(M*N) Time or O(N log M)",
      "Greedy"
    ],
    "family_tree": {
      "remedial_id": "q_392",
      "tutorial_id": "t_dp_01"
    },
    "starterCode": "def shortestWay(source: str, target: str) -> int:\n    \"\"\"Return min subsequences.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "\"abc\", \"abcbc\"",
        "expectedOutput": "2"
      },
      {
        "id": "test-2",
        "input": "\"abc\", \"acdbc\"",
        "expectedOutput": "-1"
      },
      {
        "id": "test-3",
        "input": "\"xyz\", \"xzyxz\"",
        "expectedOutput": "3"
      }
    ],
    "hints": [
      "Greedily match as many characters from target as possible using source.",
      "If a character in target doesn't exist in source, return -1."
    ],
    "solution": "def shortestWay(source: str, target: str) -> int:\n    s_chars = set(source)\n    for c in target:\n        if c not in s_chars:\n            return -1\n            \n    m, n = len(source), len(target)\n    i, j = 0, 0\n    count = 0\n    \n    while j < n:\n        # Start a new subsequence scan\n        i = 0\n        match_found = False\n        while i < m and j < n:\n            if source[i] == target[j]:\n                j += 1\n                match_found = True\n            i += 1\n        count += 1\n        \n    return count"
  },
  {
    "id": "q_63",
    "title": "Unique Paths II",
    "prompt": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
    "constraints": [
      "O(M*N) Time",
      "DP Array"
    ],
    "family_tree": {
      "remedial_id": "q_62",
      "tutorial_id": "t_dp_01"
    },
    "starterCode": "def uniquePathsWithObstacles(obstacleGrid: list[list[int]]) -> int:\n    \"\"\"Return number of unique paths.\"\"\"\n    pass",
    "testCases": [
      {
        "id": "test-1",
        "input": "[[0,0,0],[0,1,0],[0,0,0]]",
        "expectedOutput": "2"
      },
      {
        "id": "test-2",
        "input": "[[0,1],[0,0]]",
        "expectedOutput": "1"
      }
    ],
    "hints": [
      "If start or end is an obstacle, return 0.",
      "dp[i][j] = dp[i-1][j] + dp[i][j-1] if not obstacle.",
      "Handle first row/col separately."
    ],
    "solution": "def uniquePathsWithObstacles(obstacleGrid: list[list[int]]) -> int:\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1:\n        return 0\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if obstacleGrid[i][j] == 1:\n                dp[i][j] = 0\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n                \n    return dp[m-1][n-1]"
  }
]